\textbackslash{}title Qt \mbox{\hyperlink{class_template}{Template}} library

Thq Qt \mbox{\hyperlink{class_template}{Template}} Library is a set of templates within Qt dealing with containers of objects. It provides a list of objects, a stack of objects, a map (or dictionary) from one type to another, and associated iterators and algorithms.

Qt also contains similar classes that deal with pointers to objects; \textbackslash{}l \mbox{\hyperlink{class_q_value_list}{Q\+Value\+List}} vs. \textbackslash{}l \mbox{\hyperlink{class_q_list}{Q\+List}}, etc. Compared to the pointer-\/based templates, the Q\+TL offers easy copying of the container, real support for classes that e.\+g. require constructors, expand to much more object code, can often be a bit faster, require that the objects stored can be copied, and finally, have a worse record of compiler problems.

Compared to the S\+TL, the Q\+TL contains only the most important features of the S\+TL, has more regular function naming, has no platform differences, is often a little slower and often expands to less object code.

If you can not make copies of the objects you want to store you are better off with \mbox{\hyperlink{class_q_collection}{Q\+Collection}} and friends. They were designed to handle exactly that kind of pointer semantics. This applies for example to all classes derived from \textbackslash{}l Q\+Object. \mbox{\hyperlink{class_a}{A}} Q\+Object does not have a copy constructor, so using it as value is impossible. You may choose be store pointers to Q\+Objects in a \mbox{\hyperlink{class_q_value_list}{Q\+Value\+List}}, but using \mbox{\hyperlink{class_q_list}{Q\+List}} directly seems to be the better choice for this kind of application domain. \mbox{\hyperlink{class_q_list}{Q\+List}}, like all other \mbox{\hyperlink{class_q_collection}{Q\+Collection}} based containers, provides far more sanity checking than a speed-\/optimized value based container.

If you have objects that implement value semantics, use the Qt template library. Value semantics require at least 
\begin{DoxyItemize}
\item a copy constructor, 
\item an assignment operator and 
\item a default constructor, i.\+e. a constructor that does not take any arguments. 
\end{DoxyItemize}Note that a fast copy constructor is absolutely crucial for a good overall performance of the container, since many copy operations are going to happen.

Examples for value based classes are Q\+Rect, Q\+Point, Q\+Size and all simple C++ types like int, bool or double.

The Qt template library is designed for speed. Especially iterators are extremely fast. On the drawback side, less error checking is done than in the \mbox{\hyperlink{class_q_collection}{Q\+Collection}} based containers. \mbox{\hyperlink{class_a}{A}} template library container for example does not track associated iterators. This makes certain validity checks, like on removing items, impossible to perform automatically.

\doxysubsection*{Iterators }

The Qt template library deals with value objects, not with pointers. For that reason, there is no other way of iterating over containers than using iterators. This is no disadvantage as the size of an iterator matches the size of a normal pointer -\/ 32 or 64 bits depending on your C\+PU architecture.

To iterate over a container, use a loop like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typedef} \mbox{\hyperlink{class_q_value_list}{QValueList<int>}} List;}
\DoxyCodeLine{List \mbox{\hyperlink{namespacelanguages_adc25016f4569d9db5d3184abe581a8a1}{l}};}
\DoxyCodeLine{\textcolor{keywordflow}{for}( List::Iterator it = \mbox{\hyperlink{namespacelanguages_adc25016f4569d9db5d3184abe581a8a1}{l}}.begin(); it != \mbox{\hyperlink{namespacelanguages_adc25016f4569d9db5d3184abe581a8a1}{l}}.end(); ++it )}
\DoxyCodeLine{    printf(\textcolor{stringliteral}{"Number is \%i\(\backslash\)n"},*it);}
\end{DoxyCode}


begin() returns the iterator pointing at the first element, while end() returns an iterator that points {\itshape after} the last element. end() marks an invalid position, it can never be dereferenced. It\textquotesingle{}s the break condition in any iteration, may it be from begin() or from\+Last(). For maximum speed, use increment or decrement iterators with the prefix operator (++it, --it) instead of the postfix one (it++, it--), since the former is slightly faster.

The same concept applies to the other container classes\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typedef} \mbox{\hyperlink{class_q_map}{QMap<QString,QString>}} \mbox{\hyperlink{build_2generated__src_2vhdlcode_8cpp_a15d9e92a9f024447405bd8be4c7a88e8}{Map}};}
\DoxyCodeLine{\mbox{\hyperlink{build_2generated__src_2vhdlcode_8cpp_a15d9e92a9f024447405bd8be4c7a88e8}{Map}} map;}
\DoxyCodeLine{\textcolor{keywordflow}{for}( Map::Iterator it = map.begin(); it != map.end(); ++it )}
\DoxyCodeLine{    printf(\textcolor{stringliteral}{"Key=\%s Data=\%s\(\backslash\)n"}, it.key().ascii(), it.data().ascii() );}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{typedef} \mbox{\hyperlink{class_q_array}{QArray<int>}} \mbox{\hyperlink{build_2generated__src_2scanner_8cpp_aaaa51ebc6ea4da1a055fc44bbeff0fca}{Array}};}
\DoxyCodeLine{\mbox{\hyperlink{build_2generated__src_2scanner_8cpp_aaaa51ebc6ea4da1a055fc44bbeff0fca}{Array}} array;}
\DoxyCodeLine{\textcolor{keywordflow}{for}( Array::Iterator it = array.begin(); it != array.end(); ++it )}
\DoxyCodeLine{    printf(\textcolor{stringliteral}{"Data=\%i\(\backslash\)n"}, *it );}
\end{DoxyCode}


There are two kind of iterators, the volatile iterator shown in the examples above and a version that returns a const reference to its current object, the Const\+Iterator. Const iterators are required whenever the container itself is const, such as a member variable inside a const function. Assigning a Const\+Iterator to a normal Iterator is not allowed as it would violate const semantics.

\doxysubsection*{Algorithms }

The template library defines a number of algorithms that operate on its containers\+: \mbox{\hyperlink{qtl_8h_a6600ed7d73f6b27aae12d2ce7d07c89a}{q\+Heap\+Sort()}}, \mbox{\hyperlink{qtl_8h_aed508e0118549c943d14915b3c9a193d}{q\+Bubble\+Sort()}}, \mbox{\hyperlink{qtl_8h_a2516f19f53bef26e28346bed8fc24b32}{q\+Swap()}} and \mbox{\hyperlink{qtl_8h_a4038a9cab6d965f6fc62babe3b5a22e6}{q\+Copy()}}. These algorithms are implemented as template functions.

\mbox{\hyperlink{qtl_8h_a6600ed7d73f6b27aae12d2ce7d07c89a}{q\+Heap\+Sort()}} and \mbox{\hyperlink{qtl_8h_aed508e0118549c943d14915b3c9a193d}{q\+Bubble\+Sort()}} provide the well known sorting algorithms. You can use them like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typedef} \mbox{\hyperlink{class_q_value_list}{QValueList<int>}} List;}
\DoxyCodeLine{List \mbox{\hyperlink{namespacelanguages_adc25016f4569d9db5d3184abe581a8a1}{l}};}
\DoxyCodeLine{\mbox{\hyperlink{namespacelanguages_adc25016f4569d9db5d3184abe581a8a1}{l}} << 42 << 100 << 1234 << 12 << 8;}
\DoxyCodeLine{\mbox{\hyperlink{qtl_8h_a6600ed7d73f6b27aae12d2ce7d07c89a}{qHeapSort}}( l );}
\DoxyCodeLine{}
\DoxyCodeLine{List l2;}
\DoxyCodeLine{l2 << 42 << 100 << 1234 << 12 << 8;}
\DoxyCodeLine{List::Iterator \mbox{\hyperlink{gd_8h_aadf2a4297af25f4a140ea29500e8d47d}{b}} = l2.find( 100 );}
\DoxyCodeLine{List::Iterator \mbox{\hyperlink{gd_8h_abe319c426eff62b76ddf28e9a9c984df}{e}} = l2.find( 8 );}
\DoxyCodeLine{\mbox{\hyperlink{qtl_8h_a6600ed7d73f6b27aae12d2ce7d07c89a}{qHeapSort}}( b, \mbox{\hyperlink{gd_8h_abe319c426eff62b76ddf28e9a9c984df}{e}} );}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{double} arr[] = \{ 3.2, 5.6, 8.9 \};}
\DoxyCodeLine{\mbox{\hyperlink{qtl_8h_a6600ed7d73f6b27aae12d2ce7d07c89a}{qHeapSort}}( arr, arr + 3 );}
\end{DoxyCode}


The first example sorts the entire list. The second one sorts all elements enclosed in the two iterators, namely 100, 1234 and 12. The third example shows that iterators act like pointers and can be treated as such.

Naturally, the sorting templates won\textquotesingle{}t work with const iterators.

Another utility is \mbox{\hyperlink{qtl_8h_a2516f19f53bef26e28346bed8fc24b32}{q\+Swap()}}. It exchanges the values of two variables\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_q_string}{QString}} second( \textcolor{stringliteral}{"Einstein"} );}
\DoxyCodeLine{\mbox{\hyperlink{class_q_string}{QString}} name( \textcolor{stringliteral}{"Albert"} );}
\DoxyCodeLine{\mbox{\hyperlink{qtl_8h_a2516f19f53bef26e28346bed8fc24b32}{qSwap}}( second, name );}
\end{DoxyCode}


Another template function is \mbox{\hyperlink{qtl_8h_a4038a9cab6d965f6fc62babe3b5a22e6}{q\+Copy()}}. It copies a container or a slice of it to an Output\+Iterator, in this case a \mbox{\hyperlink{class_q_text_o_stream_iterator}{Q\+Text\+O\+Stream\+Iterator}}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typedef} \mbox{\hyperlink{class_q_value_list}{QValueList<int>}} List;}
\DoxyCodeLine{List \mbox{\hyperlink{namespacelanguages_adc25016f4569d9db5d3184abe581a8a1}{l}};}
\DoxyCodeLine{\mbox{\hyperlink{namespacelanguages_adc25016f4569d9db5d3184abe581a8a1}{l}} << 100 << 200 << 300;}
\DoxyCodeLine{\mbox{\hyperlink{class_q_text_o_stream}{QTextOStream}} str( stdout );}
\DoxyCodeLine{\mbox{\hyperlink{qtl_8h_a4038a9cab6d965f6fc62babe3b5a22e6}{qCopy}}( l, \mbox{\hyperlink{class_q_text_o_stream_iterator}{QTextOStreamIterator}}( str ) );}
\end{DoxyCode}


In addition, you can use any Qt template library iterator as the Output\+Iterator. Just make sure that the right hand of the iterator has as many elements present as you want to insert. The following example illustrates this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_q_string_list}{QStringList}} \mbox{\hyperlink{namespacelanguages_a835c4f4f95de4840e168b51de0e5e1a5}{l1}}, l2;}
\DoxyCodeLine{\mbox{\hyperlink{namespacelanguages_a835c4f4f95de4840e168b51de0e5e1a5}{l1}} << \textcolor{stringliteral}{"Weis"} << \textcolor{stringliteral}{"Ettrich"} << \textcolor{stringliteral}{"Arnt"} << \textcolor{stringliteral}{"Sue"};}
\DoxyCodeLine{l2 << \textcolor{stringliteral}{"Torben"} << \textcolor{stringliteral}{"Matthias"};}
\DoxyCodeLine{\mbox{\hyperlink{qtl_8h_a4038a9cab6d965f6fc62babe3b5a22e6}{qCopy}}( l2, \mbox{\hyperlink{namespacelanguages_a835c4f4f95de4840e168b51de0e5e1a5}{l1}}.begin();}
\end{DoxyCode}


At the end of this code fragment, the List l1 contains \char`\"{}\+Torben\char`\"{}, \char`\"{}\+Matthias\char`\"{}, \char`\"{}\+Arnt\char`\"{} and \char`\"{}\+Sue\char`\"{}, with the prior contents being overwritten. Another flavor of \mbox{\hyperlink{qtl_8h_a4038a9cab6d965f6fc62babe3b5a22e6}{q\+Copy()}} takes three arguments to make it possible to copy a slice of a container\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typedef} \mbox{\hyperlink{class_q_value_list}{QValueList<int>}} List;}
\DoxyCodeLine{List \mbox{\hyperlink{namespacelanguages_adc25016f4569d9db5d3184abe581a8a1}{l}};}
\DoxyCodeLine{\mbox{\hyperlink{namespacelanguages_adc25016f4569d9db5d3184abe581a8a1}{l}} << 42 << 100 << 1234 << 12 << 8;}
\DoxyCodeLine{List::Iterator \mbox{\hyperlink{gd_8h_aadf2a4297af25f4a140ea29500e8d47d}{b}} = \mbox{\hyperlink{namespacelanguages_adc25016f4569d9db5d3184abe581a8a1}{l}}.find( 100 );}
\DoxyCodeLine{List::Iterator \mbox{\hyperlink{gd_8h_abe319c426eff62b76ddf28e9a9c984df}{e}} = \mbox{\hyperlink{namespacelanguages_adc25016f4569d9db5d3184abe581a8a1}{l}}.find( 8 );}
\DoxyCodeLine{\mbox{\hyperlink{class_q_text_o_stream}{QTextOStream}} str( stdout );}
\DoxyCodeLine{\mbox{\hyperlink{qtl_8h_a4038a9cab6d965f6fc62babe3b5a22e6}{qCopy}}( b, \mbox{\hyperlink{gd_8h_abe319c426eff62b76ddf28e9a9c984df}{e}}, \mbox{\hyperlink{class_q_text_o_stream_iterator}{QTextOStreamIterator}}( str ) );}
\end{DoxyCode}


If you write new algorithms, consider writing them as template functions in order to make them usable with as many containers possible. In the above example, you could just as easily print out a standard C++ array with \mbox{\hyperlink{qtl_8h_a4038a9cab6d965f6fc62babe3b5a22e6}{q\+Copy()}}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{int} arr[] = \{ 100, 200, 300 \};}
\DoxyCodeLine{\mbox{\hyperlink{class_q_text_o_stream}{QTextOStream}} str( stdout );}
\DoxyCodeLine{\mbox{\hyperlink{qtl_8h_a4038a9cab6d965f6fc62babe3b5a22e6}{qCopy}}( arr, arr + 3, \mbox{\hyperlink{class_q_text_o_stream_iterator}{QTextOStreamIterator}}( str ) ); }
\end{DoxyCode}


\doxysubsection*{Streaming }

All mentioned containers can be serialized with the respective streaming operators. Here is an example.


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_q_data_stream}{QDataStream}} str(...);}
\DoxyCodeLine{\mbox{\hyperlink{class_q_value_list}{QValueList<QRect>}} \mbox{\hyperlink{namespacelanguages_adc25016f4569d9db5d3184abe581a8a1}{l}};}
\DoxyCodeLine{\textcolor{comment}{// ... fill the list here}}
\DoxyCodeLine{str << \mbox{\hyperlink{namespacelanguages_adc25016f4569d9db5d3184abe581a8a1}{l}};}
\end{DoxyCode}


The container can be read in again with\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_q_value_list}{QValueList<QRect>}} \mbox{\hyperlink{namespacelanguages_adc25016f4569d9db5d3184abe581a8a1}{l}};}
\DoxyCodeLine{str >> \mbox{\hyperlink{namespacelanguages_adc25016f4569d9db5d3184abe581a8a1}{l}};}
\end{DoxyCode}


The same applies to \mbox{\hyperlink{class_q_string_list}{Q\+String\+List}}, \mbox{\hyperlink{class_q_value_stack}{Q\+Value\+Stack}} and \mbox{\hyperlink{class_q_map}{Q\+Map}}. 