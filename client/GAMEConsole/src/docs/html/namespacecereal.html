<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The G.A.M.E. Project: cereal Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">The G.A.M.E. Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacecereal.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cereal Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>in certain simple scenarios. They should probably not be used if maximizing performance is the main objective.  
<a href="namespacecereal.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1access.html">access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that can be made a friend to give cereal access to non public functions.  <a href="classcereal_1_1access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1base__class.html">base_class</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a derived class to its non-virtual base class in a way that safely supports abstract classes.  <a href="structcereal_1_1base__class.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around data that can be serialized in a binary fashion.  <a href="structcereal_1_1BinaryData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1BinaryInputArchive.html">BinaryInputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An input archive designed to load data saved using <a class="el" href="classcereal_1_1BinaryOutputArchive.html" title="An output archive designed to save data in a compact binary representation.">BinaryOutputArchive</a>.  <a href="classcereal_1_1BinaryInputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1BinaryOutputArchive.html">BinaryOutputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output archive designed to save data in a compact binary representation.  <a href="classcereal_1_1BinaryOutputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1construct.html">construct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to construct types with no default constructor.  <a href="classcereal_1_1construct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1Exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception class thrown when things go wrong at runtime.  <a href="structcereal_1_1Exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1InputArchive.html">InputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base input archive class.  <a href="classcereal_1_1InputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An input archive designed to load data from JSON.  <a href="classcereal_1_1JSONInputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output archive designed to save data to JSON.  <a href="classcereal_1_1JSONOutputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1LoadAndConstruct.html">LoadAndConstruct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that allows cereal to load smart pointers to types that have no default constructor.  <a href="structcereal_1_1LoadAndConstruct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1MapItem.html">MapItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around a key and value for serializing data into maps.  <a href="structcereal_1_1MapItem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For holding name value pairs.  <a href="classcereal_1_1NameValuePair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1OutputArchive.html">OutputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base output archive class.  <a href="classcereal_1_1OutputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1PortableBinaryInputArchive.html">PortableBinaryInputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An input archive designed to load data saved using <a class="el" href="classcereal_1_1PortableBinaryOutputArchive.html" title="An output archive designed to save data in a compact binary representation portable over different ar...">PortableBinaryOutputArchive</a>.  <a href="classcereal_1_1PortableBinaryInputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1PortableBinaryOutputArchive.html">PortableBinaryOutputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output archive designed to save data in a compact binary representation portable over different architectures.  <a href="classcereal_1_1PortableBinaryOutputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1RapidJSONException.html">RapidJSONException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown when rapidjson fails an internal assertion.  <a href="structcereal_1_1RapidJSONException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around size metadata.  <a href="classcereal_1_1SizeTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1specialize.html">specialize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class used to disambiguate cases where cereal cannot detect a unique way of serializing a class.  <a href="structcereal_1_1specialize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1virtual__base__class.html">virtual_base_class</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a derived class to its virtual base class in a way that allows cereal to track inheritance.  <a href="structcereal_1_1virtual__base__class.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output archive designed to load data from XML.  <a href="classcereal_1_1XMLInputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output archive designed to save data to XML.  <a href="classcereal_1_1XMLOutputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aba657f7ef148daa498dc4fa9e579b01e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aba657f7ef148daa498dc4fa9e579b01e">size_type</a> = <a class="el" href="macros_8hpp.html#a2ad098b163a5f4829eb00fd7fb0b408d">CEREAL_SIZE_TYPE</a></td></tr>
<tr class="memdesc:aba657f7ef148daa498dc4fa9e579b01e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size type used by cereal.  <a href="namespacecereal.html#aba657f7ef148daa498dc4fa9e579b01e">More...</a><br /></td></tr>
<tr class="separator:aba657f7ef148daa498dc4fa9e579b01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac28bb730353e53b3066cc679e63bb108"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1specialize.html#ac28bb730353e53b3066cc679e63bb108">specialization</a> </td></tr>
<tr class="separator:ac28bb730353e53b3066cc679e63bb108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95185aa9f39e4ac382bb6631beb68a67"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a95185aa9f39e4ac382bb6631beb68a67">Flags</a> { <b>AllowEmptyClassElision</b> = 1
 }</td></tr>
<tr class="memdesc:a95185aa9f39e4ac382bb6631beb68a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special flags for archives.  <a href="namespacecereal.html#a95185aa9f39e4ac382bb6631beb68a67">More...</a><br /></td></tr>
<tr class="separator:a95185aa9f39e4ac382bb6631beb68a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8aeb7b414512d91291d759aaa284a8c2"><td class="memTemplParams" colspan="2"><a id="a8aeb7b414512d91291d759aaa284a8c2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8aeb7b414512d91291d759aaa284a8c2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a8aeb7b414512d91291d759aaa284a8c2">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1BinaryOutputArchive.html">BinaryOutputArchive</a> &amp;ar, T const &amp;t)</td></tr>
<tr class="memdesc:a8aeb7b414512d91291d759aaa284a8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for POD types to binary. <br /></td></tr>
<tr class="separator:a8aeb7b414512d91291d759aaa284a8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9235c50bdb3961865274a086dda972"><td class="memTemplParams" colspan="2"><a id="a4d9235c50bdb3961865274a086dda972"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4d9235c50bdb3961865274a086dda972"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a4d9235c50bdb3961865274a086dda972">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1BinaryInputArchive.html">BinaryInputArchive</a> &amp;ar, T &amp;t)</td></tr>
<tr class="memdesc:a4d9235c50bdb3961865274a086dda972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for POD types from binary. <br /></td></tr>
<tr class="separator:a4d9235c50bdb3961865274a086dda972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ec0a04e5dc57a58de5e78b5a87b8d3"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a64ec0a04e5dc57a58de5e78b5a87b8d3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a64ec0a04e5dc57a58de5e78b5a87b8d3">CEREAL_SERIALIZE_FUNCTION_NAME</a> (Archive &amp;ar, <a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:a64ec0a04e5dc57a58de5e78b5a87b8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing NVP types to binary.  <a href="namespacecereal.html#a64ec0a04e5dc57a58de5e78b5a87b8d3">More...</a><br /></td></tr>
<tr class="separator:a64ec0a04e5dc57a58de5e78b5a87b8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fb9b1468920e7e23cb2817e65fed4a"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:ac5fb9b1468920e7e23cb2817e65fed4a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ac5fb9b1468920e7e23cb2817e65fed4a">CEREAL_SERIALIZE_FUNCTION_NAME</a> (Archive &amp;ar, <a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:ac5fb9b1468920e7e23cb2817e65fed4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing SizeTags to binary.  <a href="namespacecereal.html#ac5fb9b1468920e7e23cb2817e65fed4a">More...</a><br /></td></tr>
<tr class="separator:ac5fb9b1468920e7e23cb2817e65fed4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189662781a0f3b710901f892d87792d5"><td class="memTemplParams" colspan="2"><a id="a189662781a0f3b710901f892d87792d5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a189662781a0f3b710901f892d87792d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a189662781a0f3b710901f892d87792d5">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1BinaryOutputArchive.html">BinaryOutputArchive</a> &amp;ar, <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt; const &amp;bd)</td></tr>
<tr class="memdesc:a189662781a0f3b710901f892d87792d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving binary data. <br /></td></tr>
<tr class="separator:a189662781a0f3b710901f892d87792d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8577c2834d64922e9460cad77f9a3ac"><td class="memTemplParams" colspan="2"><a id="af8577c2834d64922e9460cad77f9a3ac"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af8577c2834d64922e9460cad77f9a3ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#af8577c2834d64922e9460cad77f9a3ac">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1BinaryInputArchive.html">BinaryInputArchive</a> &amp;ar, <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt; &amp;bd)</td></tr>
<tr class="memdesc:af8577c2834d64922e9460cad77f9a3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading binary data. <br /></td></tr>
<tr class="separator:af8577c2834d64922e9460cad77f9a3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac267b8915a13f4433fc25aa9d310ee40"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac267b8915a13f4433fc25aa9d310ee40"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ac267b8915a13f4433fc25aa9d310ee40">prologue</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:ac267b8915a13f4433fc25aa9d310ee40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for NVPs for JSON archives.  <a href="namespacecereal.html#ac267b8915a13f4433fc25aa9d310ee40">More...</a><br /></td></tr>
<tr class="separator:ac267b8915a13f4433fc25aa9d310ee40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77f745fd34dd83fa6543e0fa478bdfa"><td class="memTemplParams" colspan="2"><a id="ae77f745fd34dd83fa6543e0fa478bdfa"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae77f745fd34dd83fa6543e0fa478bdfa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ae77f745fd34dd83fa6543e0fa478bdfa">prologue</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;, <a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:ae77f745fd34dd83fa6543e0fa478bdfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for NVPs for JSON archives. <br /></td></tr>
<tr class="separator:ae77f745fd34dd83fa6543e0fa478bdfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bec173adc6146ecc712921c2d257ade"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3bec173adc6146ecc712921c2d257ade"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a3bec173adc6146ecc712921c2d257ade">epilogue</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a3bec173adc6146ecc712921c2d257ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for NVPs for JSON archives.  <a href="namespacecereal.html#a3bec173adc6146ecc712921c2d257ade">More...</a><br /></td></tr>
<tr class="separator:a3bec173adc6146ecc712921c2d257ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99326c431920835d61e5bfc51b865f22"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a99326c431920835d61e5bfc51b865f22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a99326c431920835d61e5bfc51b865f22">epilogue</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;, <a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a99326c431920835d61e5bfc51b865f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for NVPs for JSON archives.  <a href="namespacecereal.html#a99326c431920835d61e5bfc51b865f22">More...</a><br /></td></tr>
<tr class="separator:a99326c431920835d61e5bfc51b865f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7ec98da774f9e0af596620859d8ccb"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5f7ec98da774f9e0af596620859d8ccb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a5f7ec98da774f9e0af596620859d8ccb">prologue</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;ar, <a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a5f7ec98da774f9e0af596620859d8ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for SizeTags for JSON archives.  <a href="namespacecereal.html#a5f7ec98da774f9e0af596620859d8ccb">More...</a><br /></td></tr>
<tr class="separator:a5f7ec98da774f9e0af596620859d8ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accec39647fd17ad5470e42a5c371701c"><td class="memTemplParams" colspan="2"><a id="accec39647fd17ad5470e42a5c371701c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:accec39647fd17ad5470e42a5c371701c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#accec39647fd17ad5470e42a5c371701c">prologue</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;, <a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:accec39647fd17ad5470e42a5c371701c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for SizeTags for JSON archives. <br /></td></tr>
<tr class="separator:accec39647fd17ad5470e42a5c371701c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92526cf5d3f4a642d918a027d2e4567"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab92526cf5d3f4a642d918a027d2e4567"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ab92526cf5d3f4a642d918a027d2e4567">epilogue</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:ab92526cf5d3f4a642d918a027d2e4567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for SizeTags for JSON archives.  <a href="namespacecereal.html#ab92526cf5d3f4a642d918a027d2e4567">More...</a><br /></td></tr>
<tr class="separator:ab92526cf5d3f4a642d918a027d2e4567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb582097a98c0558c1a6b3cf0ef52270"><td class="memTemplParams" colspan="2"><a id="acb582097a98c0558c1a6b3cf0ef52270"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:acb582097a98c0558c1a6b3cf0ef52270"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#acb582097a98c0558c1a6b3cf0ef52270">epilogue</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;, <a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:acb582097a98c0558c1a6b3cf0ef52270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for SizeTags for JSON archives. <br /></td></tr>
<tr class="separator:acb582097a98c0558c1a6b3cf0ef52270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2924cd871a88c20023171f74a68d39"><td class="memTemplParams" colspan="2">template&lt;class T , traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;::value, !traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_output_serialization, JSONOutputArchive &gt;::value, !traits::has_minimal_output_serialization&lt; T, JSONOutputArchive &gt;::value &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:aba2924cd871a88c20023171f74a68d39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aba2924cd871a88c20023171f74a68d39">prologue</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;ar, T const &amp;)</td></tr>
<tr class="memdesc:aba2924cd871a88c20023171f74a68d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for all other types for JSON archives (except minimal types)  <a href="namespacecereal.html#aba2924cd871a88c20023171f74a68d39">More...</a><br /></td></tr>
<tr class="separator:aba2924cd871a88c20023171f74a68d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88fce78fe97297ab4d22a607fee1e07"><td class="memTemplParams" colspan="2">template&lt;class T , traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;::value, !traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_input_serialization, JSONInputArchive &gt;::value, !traits::has_minimal_input_serialization&lt; T, JSONInputArchive &gt;::value &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:af88fce78fe97297ab4d22a607fee1e07"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#af88fce78fe97297ab4d22a607fee1e07">prologue</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;ar, T const &amp;)</td></tr>
<tr class="memdesc:af88fce78fe97297ab4d22a607fee1e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for all other types for JSON archives.  <a href="namespacecereal.html#af88fce78fe97297ab4d22a607fee1e07">More...</a><br /></td></tr>
<tr class="separator:af88fce78fe97297ab4d22a607fee1e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6adc568591c0a525f2c16ea5912c5b"><td class="memTemplParams" colspan="2">template&lt;class T , traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;::value, !traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_output_serialization, JSONOutputArchive &gt;::value, !traits::has_minimal_output_serialization&lt; T, JSONOutputArchive &gt;::value &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:abb6adc568591c0a525f2c16ea5912c5b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#abb6adc568591c0a525f2c16ea5912c5b">epilogue</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;ar, T const &amp;)</td></tr>
<tr class="memdesc:abb6adc568591c0a525f2c16ea5912c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for all other types other for JSON archives (except minimal types)  <a href="namespacecereal.html#abb6adc568591c0a525f2c16ea5912c5b">More...</a><br /></td></tr>
<tr class="separator:abb6adc568591c0a525f2c16ea5912c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdc10b14dce9340a8df6cb18ac74554"><td class="memTemplParams" colspan="2">template&lt;class T , traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;::value, !traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_input_serialization, JSONInputArchive &gt;::value, !traits::has_minimal_input_serialization&lt; T, JSONInputArchive &gt;::value &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:a5cdc10b14dce9340a8df6cb18ac74554"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a5cdc10b14dce9340a8df6cb18ac74554">epilogue</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;ar, T const &amp;)</td></tr>
<tr class="memdesc:a5cdc10b14dce9340a8df6cb18ac74554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for all other types other for JSON archives.  <a href="namespacecereal.html#a5cdc10b14dce9340a8df6cb18ac74554">More...</a><br /></td></tr>
<tr class="separator:a5cdc10b14dce9340a8df6cb18ac74554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956c4c0578baf265811497c965c4a382"><td class="memItemLeft" align="right" valign="top"><a id="a956c4c0578baf265811497c965c4a382"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a956c4c0578baf265811497c965c4a382">prologue</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;ar, std::nullptr_t const &amp;)</td></tr>
<tr class="memdesc:a956c4c0578baf265811497c965c4a382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for arithmetic types for JSON archives. <br /></td></tr>
<tr class="separator:a956c4c0578baf265811497c965c4a382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef075a9d94a926df8ba17689914233e2"><td class="memItemLeft" align="right" valign="top"><a id="aef075a9d94a926df8ba17689914233e2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aef075a9d94a926df8ba17689914233e2">prologue</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;, std::nullptr_t const &amp;)</td></tr>
<tr class="memdesc:aef075a9d94a926df8ba17689914233e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for arithmetic types for JSON archives. <br /></td></tr>
<tr class="separator:aef075a9d94a926df8ba17689914233e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67f92a71f4318dd69e6dec516fe57dd"><td class="memItemLeft" align="right" valign="top"><a id="ad67f92a71f4318dd69e6dec516fe57dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ad67f92a71f4318dd69e6dec516fe57dd">epilogue</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;, std::nullptr_t const &amp;)</td></tr>
<tr class="memdesc:ad67f92a71f4318dd69e6dec516fe57dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for arithmetic types for JSON archives. <br /></td></tr>
<tr class="separator:ad67f92a71f4318dd69e6dec516fe57dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9198bda1f28453a9ead2f8999e5fb449"><td class="memItemLeft" align="right" valign="top"><a id="a9198bda1f28453a9ead2f8999e5fb449"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a9198bda1f28453a9ead2f8999e5fb449">epilogue</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;, std::nullptr_t const &amp;)</td></tr>
<tr class="memdesc:a9198bda1f28453a9ead2f8999e5fb449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for arithmetic types for JSON archives. <br /></td></tr>
<tr class="separator:a9198bda1f28453a9ead2f8999e5fb449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacd1c15f7ed1793453e56a675bd0a78"><td class="memTemplParams" colspan="2"><a id="adacd1c15f7ed1793453e56a675bd0a78"></a>
template&lt;class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:adacd1c15f7ed1793453e56a675bd0a78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#adacd1c15f7ed1793453e56a675bd0a78">prologue</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;)</td></tr>
<tr class="memdesc:adacd1c15f7ed1793453e56a675bd0a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for strings for JSON archives. <br /></td></tr>
<tr class="separator:adacd1c15f7ed1793453e56a675bd0a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dde17944a1c24885e39ff673b402841"><td class="memTemplParams" colspan="2"><a id="a4dde17944a1c24885e39ff673b402841"></a>
template&lt;class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:a4dde17944a1c24885e39ff673b402841"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a4dde17944a1c24885e39ff673b402841">prologue</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;, std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;)</td></tr>
<tr class="memdesc:a4dde17944a1c24885e39ff673b402841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for strings for JSON archives. <br /></td></tr>
<tr class="separator:a4dde17944a1c24885e39ff673b402841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06f0f66ced9dd9c85377ba61054df94"><td class="memTemplParams" colspan="2"><a id="aa06f0f66ced9dd9c85377ba61054df94"></a>
template&lt;class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:aa06f0f66ced9dd9c85377ba61054df94"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aa06f0f66ced9dd9c85377ba61054df94">epilogue</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;, std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;)</td></tr>
<tr class="memdesc:aa06f0f66ced9dd9c85377ba61054df94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for strings for JSON archives. <br /></td></tr>
<tr class="separator:aa06f0f66ced9dd9c85377ba61054df94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733225f7be628b7c4dfca463d6a44253"><td class="memTemplParams" colspan="2"><a id="a733225f7be628b7c4dfca463d6a44253"></a>
template&lt;class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:a733225f7be628b7c4dfca463d6a44253"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a733225f7be628b7c4dfca463d6a44253">epilogue</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;, std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;)</td></tr>
<tr class="memdesc:a733225f7be628b7c4dfca463d6a44253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for strings for JSON archives. <br /></td></tr>
<tr class="separator:a733225f7be628b7c4dfca463d6a44253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049f4acf75e647cce18b4b98c9037cfb"><td class="memTemplParams" colspan="2"><a id="a049f4acf75e647cce18b4b98c9037cfb"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a049f4acf75e647cce18b4b98c9037cfb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a049f4acf75e647cce18b4b98c9037cfb">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;ar, <a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; const &amp;t)</td></tr>
<tr class="memdesc:a049f4acf75e647cce18b4b98c9037cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing NVP types to JSON. <br /></td></tr>
<tr class="separator:a049f4acf75e647cce18b4b98c9037cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42319b92c41f6f15a86b69fcd87246d2"><td class="memTemplParams" colspan="2"><a id="a42319b92c41f6f15a86b69fcd87246d2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a42319b92c41f6f15a86b69fcd87246d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;ar, <a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="separator:a42319b92c41f6f15a86b69fcd87246d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05ab834a18302c852181802b22d30ec"><td class="memItemLeft" align="right" valign="top"><a id="ad05ab834a18302c852181802b22d30ec"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ad05ab834a18302c852181802b22d30ec">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;ar, std::nullptr_t const &amp;t)</td></tr>
<tr class="memdesc:ad05ab834a18302c852181802b22d30ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for nullptr to JSON. <br /></td></tr>
<tr class="separator:ad05ab834a18302c852181802b22d30ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7f1f974a532bbad87a7b4d8fe746e8"><td class="memItemLeft" align="right" valign="top"><a id="aed7f1f974a532bbad87a7b4d8fe746e8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aed7f1f974a532bbad87a7b4d8fe746e8">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;ar, std::nullptr_t &amp;t)</td></tr>
<tr class="memdesc:aed7f1f974a532bbad87a7b4d8fe746e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading arithmetic from JSON. <br /></td></tr>
<tr class="separator:aed7f1f974a532bbad87a7b4d8fe746e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272e0c7b90d4591e8e0a13ebb17ca909"><td class="memTemplParams" colspan="2"><a id="a272e0c7b90d4591e8e0a13ebb17ca909"></a>
template&lt;class T , traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;::value &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:a272e0c7b90d4591e8e0a13ebb17ca909"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a272e0c7b90d4591e8e0a13ebb17ca909">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;ar, T const &amp;t)</td></tr>
<tr class="memdesc:a272e0c7b90d4591e8e0a13ebb17ca909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for arithmetic to JSON. <br /></td></tr>
<tr class="separator:a272e0c7b90d4591e8e0a13ebb17ca909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f34376d3320a6fd7be58df311bd961"><td class="memTemplParams" colspan="2"><a id="af0f34376d3320a6fd7be58df311bd961"></a>
template&lt;class T , traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;::value &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:af0f34376d3320a6fd7be58df311bd961"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#af0f34376d3320a6fd7be58df311bd961">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;ar, T &amp;t)</td></tr>
<tr class="memdesc:af0f34376d3320a6fd7be58df311bd961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading arithmetic from JSON. <br /></td></tr>
<tr class="separator:af0f34376d3320a6fd7be58df311bd961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94cbcd5c53fd79f0f97b816820b013ff"><td class="memTemplParams" colspan="2"><a id="a94cbcd5c53fd79f0f97b816820b013ff"></a>
template&lt;class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:a94cbcd5c53fd79f0f97b816820b013ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a94cbcd5c53fd79f0f97b816820b013ff">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;str)</td></tr>
<tr class="memdesc:a94cbcd5c53fd79f0f97b816820b013ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">saving string to JSON <br /></td></tr>
<tr class="separator:a94cbcd5c53fd79f0f97b816820b013ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9afcaeb51833d26e15a78d55e5ae30"><td class="memTemplParams" colspan="2"><a id="a8a9afcaeb51833d26e15a78d55e5ae30"></a>
template&lt;class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:a8a9afcaeb51833d26e15a78d55e5ae30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a8a9afcaeb51833d26e15a78d55e5ae30">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; &amp;str)</td></tr>
<tr class="memdesc:a8a9afcaeb51833d26e15a78d55e5ae30"><td class="mdescLeft">&#160;</td><td class="mdescRight">loading string from JSON <br /></td></tr>
<tr class="separator:a8a9afcaeb51833d26e15a78d55e5ae30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b30facce64dd6f270097f144f9ffde"><td class="memTemplParams" colspan="2"><a id="a66b30facce64dd6f270097f144f9ffde"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a66b30facce64dd6f270097f144f9ffde"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a66b30facce64dd6f270097f144f9ffde">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a66b30facce64dd6f270097f144f9ffde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving SizeTags to JSON. <br /></td></tr>
<tr class="separator:a66b30facce64dd6f270097f144f9ffde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e7a02ebbdcca274a8c905878725057"><td class="memTemplParams" colspan="2"><a id="ab8e7a02ebbdcca274a8c905878725057"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab8e7a02ebbdcca274a8c905878725057"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ab8e7a02ebbdcca274a8c905878725057">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;ar, <a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; &amp;st)</td></tr>
<tr class="memdesc:ab8e7a02ebbdcca274a8c905878725057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading SizeTags from JSON. <br /></td></tr>
<tr class="separator:ab8e7a02ebbdcca274a8c905878725057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246b2dae9307a97ac4d8a44c3c42a0e1"><td class="memTemplParams" colspan="2"><a id="a246b2dae9307a97ac4d8a44c3c42a0e1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a246b2dae9307a97ac4d8a44c3c42a0e1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a246b2dae9307a97ac4d8a44c3c42a0e1">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1PortableBinaryOutputArchive.html">PortableBinaryOutputArchive</a> &amp;ar, T const &amp;t)</td></tr>
<tr class="memdesc:a246b2dae9307a97ac4d8a44c3c42a0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for POD types to portable binary. <br /></td></tr>
<tr class="separator:a246b2dae9307a97ac4d8a44c3c42a0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bb22e62be241f74289805e23f43c12"><td class="memTemplParams" colspan="2"><a id="a16bb22e62be241f74289805e23f43c12"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a16bb22e62be241f74289805e23f43c12"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a16bb22e62be241f74289805e23f43c12">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1PortableBinaryInputArchive.html">PortableBinaryInputArchive</a> &amp;ar, T &amp;t)</td></tr>
<tr class="memdesc:a16bb22e62be241f74289805e23f43c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for POD types from portable binary. <br /></td></tr>
<tr class="separator:a16bb22e62be241f74289805e23f43c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba55a1d28e2db9a09ba767a4b1f16d7"><td class="memTemplParams" colspan="2"><a id="a4ba55a1d28e2db9a09ba767a4b1f16d7"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4ba55a1d28e2db9a09ba767a4b1f16d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a4ba55a1d28e2db9a09ba767a4b1f16d7">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1PortableBinaryOutputArchive.html">PortableBinaryOutputArchive</a> &amp;ar, <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt; const &amp;bd)</td></tr>
<tr class="memdesc:a4ba55a1d28e2db9a09ba767a4b1f16d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving binary data to portable binary. <br /></td></tr>
<tr class="separator:a4ba55a1d28e2db9a09ba767a4b1f16d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10780060393e472b72fb4a2158d641ec"><td class="memTemplParams" colspan="2"><a id="a10780060393e472b72fb4a2158d641ec"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a10780060393e472b72fb4a2158d641ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a10780060393e472b72fb4a2158d641ec">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1PortableBinaryInputArchive.html">PortableBinaryInputArchive</a> &amp;ar, <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt; &amp;bd)</td></tr>
<tr class="memdesc:a10780060393e472b72fb4a2158d641ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading binary data from portable binary. <br /></td></tr>
<tr class="separator:a10780060393e472b72fb4a2158d641ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2582cc8477f9482910fc5733e13f75f7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2582cc8477f9482910fc5733e13f75f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a2582cc8477f9482910fc5733e13f75f7">prologue</a> (<a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a2582cc8477f9482910fc5733e13f75f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for NVPs for XML output archives.  <a href="namespacecereal.html#a2582cc8477f9482910fc5733e13f75f7">More...</a><br /></td></tr>
<tr class="separator:a2582cc8477f9482910fc5733e13f75f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06224101dfaf6979418326a7664e13e2"><td class="memTemplParams" colspan="2"><a id="a06224101dfaf6979418326a7664e13e2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a06224101dfaf6979418326a7664e13e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a06224101dfaf6979418326a7664e13e2">prologue</a> (<a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;, <a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a06224101dfaf6979418326a7664e13e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for NVPs for XML input archives. <br /></td></tr>
<tr class="separator:a06224101dfaf6979418326a7664e13e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906ef65c3ab455598f768431bcd5f37d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a906ef65c3ab455598f768431bcd5f37d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a906ef65c3ab455598f768431bcd5f37d">epilogue</a> (<a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a906ef65c3ab455598f768431bcd5f37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for NVPs for XML output archives.  <a href="namespacecereal.html#a906ef65c3ab455598f768431bcd5f37d">More...</a><br /></td></tr>
<tr class="separator:a906ef65c3ab455598f768431bcd5f37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1af5fa5a466ad0cd89513aab823b80"><td class="memTemplParams" colspan="2"><a id="a5d1af5fa5a466ad0cd89513aab823b80"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5d1af5fa5a466ad0cd89513aab823b80"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a5d1af5fa5a466ad0cd89513aab823b80">epilogue</a> (<a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;, <a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a5d1af5fa5a466ad0cd89513aab823b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for NVPs for XML input archives. <br /></td></tr>
<tr class="separator:a5d1af5fa5a466ad0cd89513aab823b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb541e9594201d78a04cb11ad806ba0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adbb541e9594201d78a04cb11ad806ba0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#adbb541e9594201d78a04cb11ad806ba0">prologue</a> (<a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;ar, <a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:adbb541e9594201d78a04cb11ad806ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for SizeTags for XML output archives.  <a href="namespacecereal.html#adbb541e9594201d78a04cb11ad806ba0">More...</a><br /></td></tr>
<tr class="separator:adbb541e9594201d78a04cb11ad806ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25e6485f450649b931e07e0f6384a76"><td class="memTemplParams" colspan="2"><a id="aa25e6485f450649b931e07e0f6384a76"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa25e6485f450649b931e07e0f6384a76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>prologue</b> (<a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;, <a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="separator:aa25e6485f450649b931e07e0f6384a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3700f36066026da589faa60fed7ca53"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac3700f36066026da589faa60fed7ca53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ac3700f36066026da589faa60fed7ca53">epilogue</a> (<a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:ac3700f36066026da589faa60fed7ca53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for SizeTags for XML output archives.  <a href="namespacecereal.html#ac3700f36066026da589faa60fed7ca53">More...</a><br /></td></tr>
<tr class="separator:ac3700f36066026da589faa60fed7ca53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada513bbfcf8c1996e6f7a439f129a208"><td class="memTemplParams" colspan="2"><a id="ada513bbfcf8c1996e6f7a439f129a208"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ada513bbfcf8c1996e6f7a439f129a208"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>epilogue</b> (<a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;, <a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="separator:ada513bbfcf8c1996e6f7a439f129a208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af751c02a4443b571fee21416a4b899c1"><td class="memTemplParams" colspan="2">template&lt;class T , traits::DisableIf&lt; traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_output_serialization, XMLOutputArchive &gt;::value||traits::has_minimal_output_serialization&lt; T, XMLOutputArchive &gt;::value &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:af751c02a4443b571fee21416a4b899c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#af751c02a4443b571fee21416a4b899c1">prologue</a> (<a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;ar, T const &amp;)</td></tr>
<tr class="memdesc:af751c02a4443b571fee21416a4b899c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for all other types for XML output archives (except minimal types)  <a href="namespacecereal.html#af751c02a4443b571fee21416a4b899c1">More...</a><br /></td></tr>
<tr class="separator:af751c02a4443b571fee21416a4b899c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea2b824c9d003b9e2b36473db1d22c0"><td class="memTemplParams" colspan="2"><a id="a7ea2b824c9d003b9e2b36473db1d22c0"></a>
template&lt;class T , traits::DisableIf&lt; traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_input_serialization, XMLInputArchive &gt;::value||traits::has_minimal_input_serialization&lt; T, XMLInputArchive &gt;::value &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:a7ea2b824c9d003b9e2b36473db1d22c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a7ea2b824c9d003b9e2b36473db1d22c0">prologue</a> (<a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;ar, T const &amp;)</td></tr>
<tr class="memdesc:a7ea2b824c9d003b9e2b36473db1d22c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for all other types for XML input archives (except minimal types) <br /></td></tr>
<tr class="separator:a7ea2b824c9d003b9e2b36473db1d22c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ca55f7d5556527de1584198ea3c414"><td class="memTemplParams" colspan="2">template&lt;class T , traits::DisableIf&lt; traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_output_serialization, XMLOutputArchive &gt;::value||traits::has_minimal_output_serialization&lt; T, XMLOutputArchive &gt;::value &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:a16ca55f7d5556527de1584198ea3c414"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a16ca55f7d5556527de1584198ea3c414">epilogue</a> (<a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;ar, T const &amp;)</td></tr>
<tr class="memdesc:a16ca55f7d5556527de1584198ea3c414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for all other types other for XML output archives (except minimal types)  <a href="namespacecereal.html#a16ca55f7d5556527de1584198ea3c414">More...</a><br /></td></tr>
<tr class="separator:a16ca55f7d5556527de1584198ea3c414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06e3f89a66231db109db984a87e0cfd"><td class="memTemplParams" colspan="2"><a id="ae06e3f89a66231db109db984a87e0cfd"></a>
template&lt;class T , traits::DisableIf&lt; traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_input_serialization, XMLInputArchive &gt;::value||traits::has_minimal_input_serialization&lt; T, XMLInputArchive &gt;::value &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:ae06e3f89a66231db109db984a87e0cfd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ae06e3f89a66231db109db984a87e0cfd">epilogue</a> (<a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;ar, T const &amp;)</td></tr>
<tr class="memdesc:ae06e3f89a66231db109db984a87e0cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for all other types other for XML output archives (except minimal types) <br /></td></tr>
<tr class="separator:ae06e3f89a66231db109db984a87e0cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a252f7731760e1186c3c552f640fc7b"><td class="memTemplParams" colspan="2"><a id="a9a252f7731760e1186c3c552f640fc7b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a9a252f7731760e1186c3c552f640fc7b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a9a252f7731760e1186c3c552f640fc7b">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;ar, <a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; const &amp;t)</td></tr>
<tr class="memdesc:a9a252f7731760e1186c3c552f640fc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving NVP types to XML. <br /></td></tr>
<tr class="separator:a9a252f7731760e1186c3c552f640fc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a08767af52642e109545f05a4694380"><td class="memTemplParams" colspan="2"><a id="a0a08767af52642e109545f05a4694380"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a0a08767af52642e109545f05a4694380"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a0a08767af52642e109545f05a4694380">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;ar, <a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:a0a08767af52642e109545f05a4694380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading NVP types from XML. <br /></td></tr>
<tr class="separator:a0a08767af52642e109545f05a4694380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1703ea149fc65a4d7851fa85823287b2"><td class="memTemplParams" colspan="2"><a id="a1703ea149fc65a4d7851fa85823287b2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1703ea149fc65a4d7851fa85823287b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a1703ea149fc65a4d7851fa85823287b2">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a1703ea149fc65a4d7851fa85823287b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving SizeTags to XML. <br /></td></tr>
<tr class="separator:a1703ea149fc65a4d7851fa85823287b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88090838a4dbf54f907dee8969c0d5cf"><td class="memTemplParams" colspan="2"><a id="a88090838a4dbf54f907dee8969c0d5cf"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a88090838a4dbf54f907dee8969c0d5cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a88090838a4dbf54f907dee8969c0d5cf">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;ar, <a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; &amp;st)</td></tr>
<tr class="memdesc:a88090838a4dbf54f907dee8969c0d5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading SizeTags from XML. <br /></td></tr>
<tr class="separator:a88090838a4dbf54f907dee8969c0d5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6311a745c3a12848550eff8fba71f31"><td class="memTemplParams" colspan="2"><a id="ac6311a745c3a12848550eff8fba71f31"></a>
template&lt;class T , traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;::value &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:ac6311a745c3a12848550eff8fba71f31"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ac6311a745c3a12848550eff8fba71f31">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;ar, T const &amp;t)</td></tr>
<tr class="memdesc:ac6311a745c3a12848550eff8fba71f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for POD types to xml. <br /></td></tr>
<tr class="separator:ac6311a745c3a12848550eff8fba71f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea476a67114d4998f2113da658c25468"><td class="memTemplParams" colspan="2"><a id="aea476a67114d4998f2113da658c25468"></a>
template&lt;class T , traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;::value &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:aea476a67114d4998f2113da658c25468"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aea476a67114d4998f2113da658c25468">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;ar, T &amp;t)</td></tr>
<tr class="memdesc:aea476a67114d4998f2113da658c25468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for POD types from xml. <br /></td></tr>
<tr class="separator:aea476a67114d4998f2113da658c25468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63696aa0de3dc95bc27f97bf455d15e8"><td class="memTemplParams" colspan="2"><a id="a63696aa0de3dc95bc27f97bf455d15e8"></a>
template&lt;class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:a63696aa0de3dc95bc27f97bf455d15e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a63696aa0de3dc95bc27f97bf455d15e8">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;str)</td></tr>
<tr class="memdesc:a63696aa0de3dc95bc27f97bf455d15e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">saving string to xml <br /></td></tr>
<tr class="separator:a63696aa0de3dc95bc27f97bf455d15e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5b214a91e6d61bcdae422e1cf27b37"><td class="memTemplParams" colspan="2"><a id="a3f5b214a91e6d61bcdae422e1cf27b37"></a>
template&lt;class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:a3f5b214a91e6d61bcdae422e1cf27b37"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a3f5b214a91e6d61bcdae422e1cf27b37">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; &amp;str)</td></tr>
<tr class="memdesc:a3f5b214a91e6d61bcdae422e1cf27b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">loading string from xml <br /></td></tr>
<tr class="separator:a3f5b214a91e6d61bcdae422e1cf27b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8093b5f7cfd618fae6350ef7b2c09453"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a8093b5f7cfd618fae6350ef7b2c09453"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a8093b5f7cfd618fae6350ef7b2c09453">prologue</a> (Archive &amp;, T const &amp;)</td></tr>
<tr class="separator:a8093b5f7cfd618fae6350ef7b2c09453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1153b7ce7ffbb86e2c81e076a252938e"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a1153b7ce7ffbb86e2c81e076a252938e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a1153b7ce7ffbb86e2c81e076a252938e">epilogue</a> (Archive &amp;, T const &amp;)</td></tr>
<tr class="separator:a1153b7ce7ffbb86e2c81e076a252938e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa227a94792fcb26dd3fd5c4588ed38d4"><td class="memTemplParams" colspan="2"><a id="aa227a94792fcb26dd3fd5c4588ed38d4"></a>
template&lt;class KeyType , class ValueType &gt; </td></tr>
<tr class="memitem:aa227a94792fcb26dd3fd5c4588ed38d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcereal_1_1MapItem.html">MapItem</a>&lt; KeyType, ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aa227a94792fcb26dd3fd5c4588ed38d4">make_map_item</a> (KeyType &amp;&amp;key, ValueType &amp;&amp;value)</td></tr>
<tr class="memdesc:aa227a94792fcb26dd3fd5c4588ed38d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="structcereal_1_1MapItem.html" title="A wrapper around a key and value for serializing data into maps.">MapItem</a> so that human readable archives will group keys and values together. <br /></td></tr>
<tr class="separator:aa227a94792fcb26dd3fd5c4588ed38d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd86a3c7ebb03502832158513b91ee3"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , size_t N&gt; </td></tr>
<tr class="memitem:a7dd86a3c7ebb03502832158513b91ee3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value &amp;&amp;std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a7dd86a3c7ebb03502832158513b91ee3">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::array&lt; T, N &gt; const &amp;array)</td></tr>
<tr class="separator:a7dd86a3c7ebb03502832158513b91ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49547021764b554ce332679c9f9fec70"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , size_t N&gt; </td></tr>
<tr class="memitem:a49547021764b554ce332679c9f9fec70"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value &amp;&amp;std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a49547021764b554ce332679c9f9fec70">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::array&lt; T, N &gt; &amp;array)</td></tr>
<tr class="separator:a49547021764b554ce332679c9f9fec70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008414a8d23778c73ddb47270d7d477f"><td class="memTemplParams" colspan="2"><a id="a008414a8d23778c73ddb47270d7d477f"></a>
template&lt;class Archive , class T , size_t N&gt; </td></tr>
<tr class="memitem:a008414a8d23778c73ddb47270d7d477f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value||!std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a008414a8d23778c73ddb47270d7d477f">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::array&lt; T, N &gt; const &amp;array)</td></tr>
<tr class="memdesc:a008414a8d23778c73ddb47270d7d477f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::array all other types. <br /></td></tr>
<tr class="separator:a008414a8d23778c73ddb47270d7d477f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e9db02cc3b58b053b47fb1456d8c92"><td class="memTemplParams" colspan="2"><a id="aa2e9db02cc3b58b053b47fb1456d8c92"></a>
template&lt;class Archive , class T , size_t N&gt; </td></tr>
<tr class="memitem:aa2e9db02cc3b58b053b47fb1456d8c92"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value||!std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aa2e9db02cc3b58b053b47fb1456d8c92">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::array&lt; T, N &gt; &amp;array)</td></tr>
<tr class="memdesc:aa2e9db02cc3b58b053b47fb1456d8c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::array all other types. <br /></td></tr>
<tr class="separator:aa2e9db02cc3b58b053b47fb1456d8c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397c996c1b3e8bdcb3f43f11edf91126"><td class="memTemplParams" colspan="2">template&lt;class Archive , size_t N, traits::EnableIf&lt; traits::is_output_serializable&lt; BinaryData&lt; std::uint32_t &gt;, Archive &gt;::value &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:a397c996c1b3e8bdcb3f43f11edf91126"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a397c996c1b3e8bdcb3f43f11edf91126">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::bitset&lt; N &gt; const &amp;bits)</td></tr>
<tr class="memdesc:a397c996c1b3e8bdcb3f43f11edf91126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing (save) for std::bitset when <a class="el" href="structcereal_1_1BinaryData.html" title="A wrapper around data that can be serialized in a binary fashion.">BinaryData</a> optimization supported.  <a href="namespacecereal.html#a397c996c1b3e8bdcb3f43f11edf91126">More...</a><br /></td></tr>
<tr class="separator:a397c996c1b3e8bdcb3f43f11edf91126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8cfa5e251b7a85343f0a92e93f50a60"><td class="memTemplParams" colspan="2"><a id="ad8cfa5e251b7a85343f0a92e93f50a60"></a>
template&lt;class Archive , size_t N&gt; </td></tr>
<tr class="memitem:ad8cfa5e251b7a85343f0a92e93f50a60"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ad8cfa5e251b7a85343f0a92e93f50a60">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::bitset&lt; N &gt; &amp;bits)</td></tr>
<tr class="memdesc:ad8cfa5e251b7a85343f0a92e93f50a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing (load) for std::bitset. <br /></td></tr>
<tr class="separator:ad8cfa5e251b7a85343f0a92e93f50a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03bbaa4691f7fe57e41ffd108907c9b"><td class="memTemplParams" colspan="2"><a id="ab03bbaa4691f7fe57e41ffd108907c9b"></a>
template&lt;class Archive , typename VariantType1 , typename... VariantTypes&gt; </td></tr>
<tr class="memitem:ab03bbaa4691f7fe57e41ffd108907c9b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ab03bbaa4691f7fe57e41ffd108907c9b">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, boost::variant&lt; VariantType1, VariantTypes... &gt; const &amp;variant)</td></tr>
<tr class="memdesc:ab03bbaa4691f7fe57e41ffd108907c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for boost::variant. <br /></td></tr>
<tr class="separator:ab03bbaa4691f7fe57e41ffd108907c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee601e5b44bdc9acdef94097cbb43df"><td class="memTemplParams" colspan="2"><a id="a6ee601e5b44bdc9acdef94097cbb43df"></a>
template&lt;class Archive , typename VariantType1 , typename... VariantTypes&gt; </td></tr>
<tr class="memitem:a6ee601e5b44bdc9acdef94097cbb43df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a6ee601e5b44bdc9acdef94097cbb43df">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, boost::variant&lt; VariantType1, VariantTypes... &gt; &amp;variant)</td></tr>
<tr class="memdesc:a6ee601e5b44bdc9acdef94097cbb43df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for boost::variant. <br /></td></tr>
<tr class="separator:a6ee601e5b44bdc9acdef94097cbb43df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873e6efe3a391c89edbee86fb2a4b349"><td class="memTemplParams" colspan="2"><a id="a873e6efe3a391c89edbee86fb2a4b349"></a>
template&lt;class Archive , class R , class P &gt; </td></tr>
<tr class="memitem:a873e6efe3a391c89edbee86fb2a4b349"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a873e6efe3a391c89edbee86fb2a4b349">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::chrono::duration&lt; R, P &gt; const &amp;dur)</td></tr>
<tr class="memdesc:a873e6efe3a391c89edbee86fb2a4b349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::chrono::duration. <br /></td></tr>
<tr class="separator:a873e6efe3a391c89edbee86fb2a4b349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c5a2d538bb7606e5500f5e3a107e30"><td class="memTemplParams" colspan="2"><a id="a09c5a2d538bb7606e5500f5e3a107e30"></a>
template&lt;class Archive , class R , class P &gt; </td></tr>
<tr class="memitem:a09c5a2d538bb7606e5500f5e3a107e30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a09c5a2d538bb7606e5500f5e3a107e30">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::chrono::duration&lt; R, P &gt; &amp;dur)</td></tr>
<tr class="memdesc:a09c5a2d538bb7606e5500f5e3a107e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::chrono::duration. <br /></td></tr>
<tr class="separator:a09c5a2d538bb7606e5500f5e3a107e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977c1527242726fecf6cb1f492683ca6"><td class="memTemplParams" colspan="2"><a id="a977c1527242726fecf6cb1f492683ca6"></a>
template&lt;class Archive , class C , class D &gt; </td></tr>
<tr class="memitem:a977c1527242726fecf6cb1f492683ca6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a977c1527242726fecf6cb1f492683ca6">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::chrono::time_point&lt; C, D &gt; const &amp;dur)</td></tr>
<tr class="memdesc:a977c1527242726fecf6cb1f492683ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::chrono::time_point. <br /></td></tr>
<tr class="separator:a977c1527242726fecf6cb1f492683ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b65d3b13a15b4f35c1b21553ab7649"><td class="memTemplParams" colspan="2"><a id="ab8b65d3b13a15b4f35c1b21553ab7649"></a>
template&lt;class Archive , class C , class D &gt; </td></tr>
<tr class="memitem:ab8b65d3b13a15b4f35c1b21553ab7649"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ab8b65d3b13a15b4f35c1b21553ab7649">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::chrono::time_point&lt; C, D &gt; &amp;dur)</td></tr>
<tr class="memdesc:ab8b65d3b13a15b4f35c1b21553ab7649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::chrono::time_point. <br /></td></tr>
<tr class="separator:ab8b65d3b13a15b4f35c1b21553ab7649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073d35d55ad8dc81ce149fb799aab9f0"><td class="memTemplParams" colspan="2"><a id="a073d35d55ad8dc81ce149fb799aab9f0"></a>
template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a073d35d55ad8dc81ce149fb799aab9f0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="classcereal_1_1common__detail_1_1is__enum.html">common_detail::is_enum</a>&lt; T &gt;::value, typename <a class="el" href="classcereal_1_1common__detail_1_1is__enum.html">common_detail::is_enum</a>&lt; T &gt;::base_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a073d35d55ad8dc81ce149fb799aab9f0">CEREAL_SAVE_MINIMAL_FUNCTION_NAME</a> (Archive const &amp;, T const &amp;t)</td></tr>
<tr class="memdesc:a073d35d55ad8dc81ce149fb799aab9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for enum types. <br /></td></tr>
<tr class="separator:a073d35d55ad8dc81ce149fb799aab9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa110605d7a57863ad6cf9370332f446d"><td class="memTemplParams" colspan="2"><a id="aa110605d7a57863ad6cf9370332f446d"></a>
template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:aa110605d7a57863ad6cf9370332f446d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="classcereal_1_1common__detail_1_1is__enum.html">common_detail::is_enum</a>&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aa110605d7a57863ad6cf9370332f446d">CEREAL_LOAD_MINIMAL_FUNCTION_NAME</a> (Archive const &amp;, T &amp;&amp;t, typename <a class="el" href="classcereal_1_1common__detail_1_1is__enum.html">common_detail::is_enum</a>&lt; T &gt;::base_type const &amp;value)</td></tr>
<tr class="memdesc:aa110605d7a57863ad6cf9370332f446d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for enum types. <br /></td></tr>
<tr class="separator:aa110605d7a57863ad6cf9370332f446d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676a85ac8cfcd512a743f930a10b6770"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a676a85ac8cfcd512a743f930a10b6770"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a676a85ac8cfcd512a743f930a10b6770">CEREAL_SERIALIZE_FUNCTION_NAME</a> (Archive &amp;, T *&amp;)</td></tr>
<tr class="memdesc:a676a85ac8cfcd512a743f930a10b6770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for raw pointers.  <a href="namespacecereal.html#a676a85ac8cfcd512a743f930a10b6770">More...</a><br /></td></tr>
<tr class="separator:a676a85ac8cfcd512a743f930a10b6770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22053a71b907666422b3a281be15bbc0"><td class="memTemplParams" colspan="2"><a id="a22053a71b907666422b3a281be15bbc0"></a>
template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a22053a71b907666422b3a281be15bbc0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_array&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a22053a71b907666422b3a281be15bbc0">CEREAL_SERIALIZE_FUNCTION_NAME</a> (Archive &amp;ar, T &amp;array)</td></tr>
<tr class="memdesc:a22053a71b907666422b3a281be15bbc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for C style arrays. <br /></td></tr>
<tr class="separator:a22053a71b907666422b3a281be15bbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548257a795f8540c86333d0758fb99d5"><td class="memTemplParams" colspan="2"><a id="a548257a795f8540c86333d0758fb99d5"></a>
template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a548257a795f8540c86333d0758fb99d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a548257a795f8540c86333d0758fb99d5">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::complex&lt; T &gt; const &amp;comp)</td></tr>
<tr class="memdesc:a548257a795f8540c86333d0758fb99d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing (save) for std::complex. <br /></td></tr>
<tr class="separator:a548257a795f8540c86333d0758fb99d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc7cefa0f45ae9d873598fdc607320e"><td class="memTemplParams" colspan="2"><a id="afdc7cefa0f45ae9d873598fdc607320e"></a>
template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:afdc7cefa0f45ae9d873598fdc607320e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#afdc7cefa0f45ae9d873598fdc607320e">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::complex&lt; T &gt; &amp;bits)</td></tr>
<tr class="memdesc:afdc7cefa0f45ae9d873598fdc607320e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing (load) for std::complex. <br /></td></tr>
<tr class="separator:afdc7cefa0f45ae9d873598fdc607320e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5992e59041b20f902dd4fa0b2c62f1"><td class="memTemplParams" colspan="2"><a id="a0c5992e59041b20f902dd4fa0b2c62f1"></a>
template&lt;class Archive , template&lt; typename... &gt; class Map, typename... Args, typename  = typename Map&lt;Args...&gt;::mapped_type&gt; </td></tr>
<tr class="memitem:a0c5992e59041b20f902dd4fa0b2c62f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a0c5992e59041b20f902dd4fa0b2c62f1">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, Map&lt; Args... &gt; const &amp;map)</td></tr>
<tr class="memdesc:a0c5992e59041b20f902dd4fa0b2c62f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std-like pair associative containers. <br /></td></tr>
<tr class="separator:a0c5992e59041b20f902dd4fa0b2c62f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679144f687ff95c7111ff96bccc573b3"><td class="memTemplParams" colspan="2"><a id="a679144f687ff95c7111ff96bccc573b3"></a>
template&lt;class Archive , template&lt; typename... &gt; class Map, typename... Args, typename  = typename Map&lt;Args...&gt;::mapped_type&gt; </td></tr>
<tr class="memitem:a679144f687ff95c7111ff96bccc573b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a679144f687ff95c7111ff96bccc573b3">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, Map&lt; Args... &gt; &amp;map)</td></tr>
<tr class="memdesc:a679144f687ff95c7111ff96bccc573b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std-like pair associative containers. <br /></td></tr>
<tr class="separator:a679144f687ff95c7111ff96bccc573b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7e7370c46e4a819bd35fc1cdb856ad"><td class="memTemplParams" colspan="2"><a id="a2e7e7370c46e4a819bd35fc1cdb856ad"></a>
template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:a2e7e7370c46e4a819bd35fc1cdb856ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a2e7e7370c46e4a819bd35fc1cdb856ad">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::deque&lt; T, A &gt; const &amp;deque)</td></tr>
<tr class="memdesc:a2e7e7370c46e4a819bd35fc1cdb856ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::deque. <br /></td></tr>
<tr class="separator:a2e7e7370c46e4a819bd35fc1cdb856ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284b8541ec2e00a17dada43f2d59d878"><td class="memTemplParams" colspan="2"><a id="a284b8541ec2e00a17dada43f2d59d878"></a>
template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:a284b8541ec2e00a17dada43f2d59d878"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a284b8541ec2e00a17dada43f2d59d878">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::deque&lt; T, A &gt; &amp;deque)</td></tr>
<tr class="memdesc:a284b8541ec2e00a17dada43f2d59d878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::deque. <br /></td></tr>
<tr class="separator:a284b8541ec2e00a17dada43f2d59d878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69af5df93ccfbbb3cc02575e3aeadbc6"><td class="memTemplParams" colspan="2"><a id="a69af5df93ccfbbb3cc02575e3aeadbc6"></a>
template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:a69af5df93ccfbbb3cc02575e3aeadbc6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a69af5df93ccfbbb3cc02575e3aeadbc6">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::forward_list&lt; T, A &gt; const &amp;forward_list)</td></tr>
<tr class="memdesc:a69af5df93ccfbbb3cc02575e3aeadbc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::forward_list all other types. <br /></td></tr>
<tr class="separator:a69af5df93ccfbbb3cc02575e3aeadbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e9e22a3423e77493cee1d858372579"><td class="memTemplParams" colspan="2"><a id="a42e9e22a3423e77493cee1d858372579"></a>
template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:a42e9e22a3423e77493cee1d858372579"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a42e9e22a3423e77493cee1d858372579">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::forward_list&lt; T, A &gt; &amp;forward_list)</td></tr>
<tr class="memdesc:a42e9e22a3423e77493cee1d858372579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::forward_list all other types from. <br /></td></tr>
<tr class="separator:a42e9e22a3423e77493cee1d858372579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f9cfc9a4055c8a49eb050b02cd3357"><td class="memTemplParams" colspan="2"><a id="a02f9cfc9a4055c8a49eb050b02cd3357"></a>
template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a02f9cfc9a4055c8a49eb050b02cd3357"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a02f9cfc9a4055c8a49eb050b02cd3357">serialize</a> (Archive &amp;, std::less&lt; T &gt; &amp;)</td></tr>
<tr class="memdesc:a02f9cfc9a4055c8a49eb050b02cd3357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::less. <br /></td></tr>
<tr class="separator:a02f9cfc9a4055c8a49eb050b02cd3357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5738ab4196d02509a5b69a58c7ca6ba"><td class="memTemplParams" colspan="2"><a id="ad5738ab4196d02509a5b69a58c7ca6ba"></a>
template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:ad5738ab4196d02509a5b69a58c7ca6ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ad5738ab4196d02509a5b69a58c7ca6ba">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::list&lt; T, A &gt; const &amp;list)</td></tr>
<tr class="memdesc:ad5738ab4196d02509a5b69a58c7ca6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::list. <br /></td></tr>
<tr class="separator:ad5738ab4196d02509a5b69a58c7ca6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55808d42ce0c468d57c34bbc07827e59"><td class="memTemplParams" colspan="2"><a id="a55808d42ce0c468d57c34bbc07827e59"></a>
template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:a55808d42ce0c468d57c34bbc07827e59"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a55808d42ce0c468d57c34bbc07827e59">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::list&lt; T, A &gt; &amp;list)</td></tr>
<tr class="memdesc:a55808d42ce0c468d57c34bbc07827e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::list. <br /></td></tr>
<tr class="separator:a55808d42ce0c468d57c34bbc07827e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32e5d8031bde714f82138ab097ce135"><td class="memTemplParams" colspan="2"><a id="ae32e5d8031bde714f82138ab097ce135"></a>
template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:ae32e5d8031bde714f82138ab097ce135"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ae32e5d8031bde714f82138ab097ce135">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::shared_ptr&lt; T &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:ae32e5d8031bde714f82138ab097ce135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::shared_ptr for non polymorphic types. <br /></td></tr>
<tr class="separator:ae32e5d8031bde714f82138ab097ce135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917df6d9415473be28a8a0791d293a35"><td class="memTemplParams" colspan="2"><a id="a917df6d9415473be28a8a0791d293a35"></a>
template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a917df6d9415473be28a8a0791d293a35"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a917df6d9415473be28a8a0791d293a35">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::shared_ptr&lt; T &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a917df6d9415473be28a8a0791d293a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::shared_ptr, case when no user load and construct for non polymorphic types. <br /></td></tr>
<tr class="separator:a917df6d9415473be28a8a0791d293a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01e0b5b328b5a0db1fd64f75ad4cb9d"><td class="memTemplParams" colspan="2"><a id="aa01e0b5b328b5a0db1fd64f75ad4cb9d"></a>
template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:aa01e0b5b328b5a0db1fd64f75ad4cb9d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aa01e0b5b328b5a0db1fd64f75ad4cb9d">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::weak_ptr&lt; T &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:aa01e0b5b328b5a0db1fd64f75ad4cb9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::weak_ptr for non polymorphic types. <br /></td></tr>
<tr class="separator:aa01e0b5b328b5a0db1fd64f75ad4cb9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a621b3b41cd8058c9bde03b753aa86a"><td class="memTemplParams" colspan="2"><a id="a4a621b3b41cd8058c9bde03b753aa86a"></a>
template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a4a621b3b41cd8058c9bde03b753aa86a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a4a621b3b41cd8058c9bde03b753aa86a">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::weak_ptr&lt; T &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a4a621b3b41cd8058c9bde03b753aa86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::weak_ptr for non polymorphic types. <br /></td></tr>
<tr class="separator:a4a621b3b41cd8058c9bde03b753aa86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5365f19aa89df7a849d13592a41ea8"><td class="memTemplParams" colspan="2"><a id="aaf5365f19aa89df7a849d13592a41ea8"></a>
template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:aaf5365f19aa89df7a849d13592a41ea8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aaf5365f19aa89df7a849d13592a41ea8">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:aaf5365f19aa89df7a849d13592a41ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::unique_ptr for non polymorphic types. <br /></td></tr>
<tr class="separator:aaf5365f19aa89df7a849d13592a41ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1ca7735ec31c2b5e9d13be281321de"><td class="memTemplParams" colspan="2"><a id="acb1ca7735ec31c2b5e9d13be281321de"></a>
template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:acb1ca7735ec31c2b5e9d13be281321de"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#acb1ca7735ec31c2b5e9d13be281321de">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; &amp;ptr)</td></tr>
<tr class="memdesc:acb1ca7735ec31c2b5e9d13be281321de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::unique_ptr, case when user provides load_and_construct for non polymorphic types. <br /></td></tr>
<tr class="separator:acb1ca7735ec31c2b5e9d13be281321de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2dd1ac3ad73ad7203acdc21d7ea995a"><td class="memTemplParams" colspan="2"><a id="ac2dd1ac3ad73ad7203acdc21d7ea995a"></a>
template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:ac2dd1ac3ad73ad7203acdc21d7ea995a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ac2dd1ac3ad73ad7203acdc21d7ea995a">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, <a class="el" href="structcereal_1_1memory__detail_1_1PtrWrapper.html">memory_detail::PtrWrapper</a>&lt; std::shared_ptr&lt; T &gt; const &amp; &gt; const &amp;wrapper)</td></tr>
<tr class="memdesc:ac2dd1ac3ad73ad7203acdc21d7ea995a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::shared_ptr (wrapper implementation) <br /></td></tr>
<tr class="separator:ac2dd1ac3ad73ad7203acdc21d7ea995a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0396907ef9745cad405f1ff62215e28c"><td class="memTemplParams" colspan="2"><a id="a0396907ef9745cad405f1ff62215e28c"></a>
template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a0396907ef9745cad405f1ff62215e28c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt; T, Archive &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a0396907ef9745cad405f1ff62215e28c">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, <a class="el" href="structcereal_1_1memory__detail_1_1PtrWrapper.html">memory_detail::PtrWrapper</a>&lt; std::shared_ptr&lt; T &gt; &amp; &gt; &amp;wrapper)</td></tr>
<tr class="memdesc:a0396907ef9745cad405f1ff62215e28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::shared_ptr, case when user load and construct (wrapper implementation) <br /></td></tr>
<tr class="separator:a0396907ef9745cad405f1ff62215e28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5809a4b7750b5a0c26c2818f0270f01"><td class="memTemplParams" colspan="2"><a id="aa5809a4b7750b5a0c26c2818f0270f01"></a>
template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:aa5809a4b7750b5a0c26c2818f0270f01"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt; T, Archive &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aa5809a4b7750b5a0c26c2818f0270f01">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, <a class="el" href="structcereal_1_1memory__detail_1_1PtrWrapper.html">memory_detail::PtrWrapper</a>&lt; std::shared_ptr&lt; T &gt; &amp; &gt; &amp;wrapper)</td></tr>
<tr class="memdesc:aa5809a4b7750b5a0c26c2818f0270f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::shared_ptr, case when no user load and construct (wrapper implementation) <br /></td></tr>
<tr class="separator:aa5809a4b7750b5a0c26c2818f0270f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5576cf5fa2dc553adca652003d232d"><td class="memTemplParams" colspan="2"><a id="a7a5576cf5fa2dc553adca652003d232d"></a>
template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:a7a5576cf5fa2dc553adca652003d232d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a7a5576cf5fa2dc553adca652003d232d">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, <a class="el" href="structcereal_1_1memory__detail_1_1PtrWrapper.html">memory_detail::PtrWrapper</a>&lt; std::unique_ptr&lt; T, D &gt; const &amp; &gt; const &amp;wrapper)</td></tr>
<tr class="memdesc:a7a5576cf5fa2dc553adca652003d232d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::unique_ptr (wrapper implementation) <br /></td></tr>
<tr class="separator:a7a5576cf5fa2dc553adca652003d232d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a7f7ebd3faec04dd809f5b203a6adb"><td class="memTemplParams" colspan="2"><a id="ae0a7f7ebd3faec04dd809f5b203a6adb"></a>
template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:ae0a7f7ebd3faec04dd809f5b203a6adb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt; T, Archive &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ae0a7f7ebd3faec04dd809f5b203a6adb">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, <a class="el" href="structcereal_1_1memory__detail_1_1PtrWrapper.html">memory_detail::PtrWrapper</a>&lt; std::unique_ptr&lt; T, D &gt; &amp; &gt; &amp;wrapper)</td></tr>
<tr class="memdesc:ae0a7f7ebd3faec04dd809f5b203a6adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::unique_ptr, case when user provides load_and_construct (wrapper implementation) <br /></td></tr>
<tr class="separator:ae0a7f7ebd3faec04dd809f5b203a6adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd284d9609d7b9c09d8779439e7f0c1"><td class="memTemplParams" colspan="2"><a id="a9fd284d9609d7b9c09d8779439e7f0c1"></a>
template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:a9fd284d9609d7b9c09d8779439e7f0c1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt; T, Archive &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a9fd284d9609d7b9c09d8779439e7f0c1">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, <a class="el" href="structcereal_1_1memory__detail_1_1PtrWrapper.html">memory_detail::PtrWrapper</a>&lt; std::unique_ptr&lt; T, D &gt; &amp; &gt; &amp;wrapper)</td></tr>
<tr class="memdesc:a9fd284d9609d7b9c09d8779439e7f0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::unique_ptr, case when no load_and_construct (wrapper implementation) <br /></td></tr>
<tr class="separator:a9fd284d9609d7b9c09d8779439e7f0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759a15c02fad55311de9e5dd645a7319"><td class="memTemplParams" colspan="2"><a id="a759a15c02fad55311de9e5dd645a7319"></a>
template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a759a15c02fad55311de9e5dd645a7319"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value &amp;&amp;std::is_abstract&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a759a15c02fad55311de9e5dd645a7319">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::shared_ptr&lt; T &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:a759a15c02fad55311de9e5dd645a7319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::shared_ptr for polymorphic types, abstract. <br /></td></tr>
<tr class="separator:a759a15c02fad55311de9e5dd645a7319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e1ce1157644fad605ade652112daf1"><td class="memTemplParams" colspan="2"><a id="aa6e1ce1157644fad605ade652112daf1"></a>
template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:aa6e1ce1157644fad605ade652112daf1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value &amp;&amp;!std::is_abstract&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aa6e1ce1157644fad605ade652112daf1">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::shared_ptr&lt; T &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:aa6e1ce1157644fad605ade652112daf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::shared_ptr for polymorphic types, not abstract. <br /></td></tr>
<tr class="separator:aa6e1ce1157644fad605ade652112daf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162562abb32a0be716dbfb98f1a31a33"><td class="memTemplParams" colspan="2"><a id="a162562abb32a0be716dbfb98f1a31a33"></a>
template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a162562abb32a0be716dbfb98f1a31a33"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a162562abb32a0be716dbfb98f1a31a33">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::shared_ptr&lt; T &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a162562abb32a0be716dbfb98f1a31a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::shared_ptr for polymorphic types. <br /></td></tr>
<tr class="separator:a162562abb32a0be716dbfb98f1a31a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fd3494d3937e25e00c63e3822e8037"><td class="memTemplParams" colspan="2"><a id="af0fd3494d3937e25e00c63e3822e8037"></a>
template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:af0fd3494d3937e25e00c63e3822e8037"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#af0fd3494d3937e25e00c63e3822e8037">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::weak_ptr&lt; T &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:af0fd3494d3937e25e00c63e3822e8037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::weak_ptr for polymorphic types. <br /></td></tr>
<tr class="separator:af0fd3494d3937e25e00c63e3822e8037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0cbd30aefc13f4a54094593603db13c"><td class="memTemplParams" colspan="2"><a id="aa0cbd30aefc13f4a54094593603db13c"></a>
template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:aa0cbd30aefc13f4a54094593603db13c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aa0cbd30aefc13f4a54094593603db13c">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::weak_ptr&lt; T &gt; &amp;ptr)</td></tr>
<tr class="memdesc:aa0cbd30aefc13f4a54094593603db13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::weak_ptr for polymorphic types. <br /></td></tr>
<tr class="separator:aa0cbd30aefc13f4a54094593603db13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7690f06f7ad55613cec7ae757b1750"><td class="memTemplParams" colspan="2"><a id="aba7690f06f7ad55613cec7ae757b1750"></a>
template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:aba7690f06f7ad55613cec7ae757b1750"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value &amp;&amp;std::is_abstract&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aba7690f06f7ad55613cec7ae757b1750">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:aba7690f06f7ad55613cec7ae757b1750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::unique_ptr for polymorphic types that are abstract. <br /></td></tr>
<tr class="separator:aba7690f06f7ad55613cec7ae757b1750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7296078465310c1af67d5674d7258c2"><td class="memTemplParams" colspan="2"><a id="ab7296078465310c1af67d5674d7258c2"></a>
template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:ab7296078465310c1af67d5674d7258c2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value &amp;&amp;!std::is_abstract&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ab7296078465310c1af67d5674d7258c2">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:ab7296078465310c1af67d5674d7258c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::unique_ptr for polymorphic types, not abstract. <br /></td></tr>
<tr class="separator:ab7296078465310c1af67d5674d7258c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1d69a4d25ed7715c105b14ed6f8957"><td class="memTemplParams" colspan="2"><a id="a8d1d69a4d25ed7715c105b14ed6f8957"></a>
template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:a8d1d69a4d25ed7715c105b14ed6f8957"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a8d1d69a4d25ed7715c105b14ed6f8957">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a8d1d69a4d25ed7715c105b14ed6f8957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::unique_ptr, case when user provides load_and_construct for polymorphic types. <br /></td></tr>
<tr class="separator:a8d1d69a4d25ed7715c105b14ed6f8957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196f5ec0e6eb126730ee5fb7339fb8be"><td class="memTemplParams" colspan="2"><a id="a196f5ec0e6eb126730ee5fb7339fb8be"></a>
template&lt;class Archive , class T , class C &gt; </td></tr>
<tr class="memitem:a196f5ec0e6eb126730ee5fb7339fb8be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a196f5ec0e6eb126730ee5fb7339fb8be">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::queue&lt; T, C &gt; const &amp;queue)</td></tr>
<tr class="memdesc:a196f5ec0e6eb126730ee5fb7339fb8be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::queue. <br /></td></tr>
<tr class="separator:a196f5ec0e6eb126730ee5fb7339fb8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663f35fc093d002d4e07c0e965178525"><td class="memTemplParams" colspan="2"><a id="a663f35fc093d002d4e07c0e965178525"></a>
template&lt;class Archive , class T , class C &gt; </td></tr>
<tr class="memitem:a663f35fc093d002d4e07c0e965178525"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a663f35fc093d002d4e07c0e965178525">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::queue&lt; T, C &gt; &amp;queue)</td></tr>
<tr class="memdesc:a663f35fc093d002d4e07c0e965178525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::queue. <br /></td></tr>
<tr class="separator:a663f35fc093d002d4e07c0e965178525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1957ae53b8fc963c0ed3e831deae7ca"><td class="memTemplParams" colspan="2"><a id="ad1957ae53b8fc963c0ed3e831deae7ca"></a>
template&lt;class Archive , class T , class C , class Comp &gt; </td></tr>
<tr class="memitem:ad1957ae53b8fc963c0ed3e831deae7ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ad1957ae53b8fc963c0ed3e831deae7ca">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::priority_queue&lt; T, C, Comp &gt; const &amp;priority_queue)</td></tr>
<tr class="memdesc:ad1957ae53b8fc963c0ed3e831deae7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::priority_queue. <br /></td></tr>
<tr class="separator:ad1957ae53b8fc963c0ed3e831deae7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9335c1a68710bfa8f49ae3a217b32623"><td class="memTemplParams" colspan="2"><a id="a9335c1a68710bfa8f49ae3a217b32623"></a>
template&lt;class Archive , class T , class C , class Comp &gt; </td></tr>
<tr class="memitem:a9335c1a68710bfa8f49ae3a217b32623"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a9335c1a68710bfa8f49ae3a217b32623">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::priority_queue&lt; T, C, Comp &gt; &amp;priority_queue)</td></tr>
<tr class="memdesc:a9335c1a68710bfa8f49ae3a217b32623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::priority_queue. <br /></td></tr>
<tr class="separator:a9335c1a68710bfa8f49ae3a217b32623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a8cea063806602d60157cf1fb90878"><td class="memTemplParams" colspan="2"><a id="a76a8cea063806602d60157cf1fb90878"></a>
template&lt;class Archive , class K , class C , class A &gt; </td></tr>
<tr class="memitem:a76a8cea063806602d60157cf1fb90878"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a76a8cea063806602d60157cf1fb90878">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::set&lt; K, C, A &gt; const &amp;set)</td></tr>
<tr class="memdesc:a76a8cea063806602d60157cf1fb90878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::set. <br /></td></tr>
<tr class="separator:a76a8cea063806602d60157cf1fb90878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a65f7506d96c59b25e5ad4bb6d6ad5"><td class="memTemplParams" colspan="2"><a id="a79a65f7506d96c59b25e5ad4bb6d6ad5"></a>
template&lt;class Archive , class K , class C , class A &gt; </td></tr>
<tr class="memitem:a79a65f7506d96c59b25e5ad4bb6d6ad5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a79a65f7506d96c59b25e5ad4bb6d6ad5">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::set&lt; K, C, A &gt; &amp;set)</td></tr>
<tr class="memdesc:a79a65f7506d96c59b25e5ad4bb6d6ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::set. <br /></td></tr>
<tr class="separator:a79a65f7506d96c59b25e5ad4bb6d6ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7424502dce9a6a12bc8b0c34c8fa04"><td class="memTemplParams" colspan="2"><a id="aba7424502dce9a6a12bc8b0c34c8fa04"></a>
template&lt;class Archive , class K , class C , class A &gt; </td></tr>
<tr class="memitem:aba7424502dce9a6a12bc8b0c34c8fa04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aba7424502dce9a6a12bc8b0c34c8fa04">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::multiset&lt; K, C, A &gt; const &amp;multiset)</td></tr>
<tr class="memdesc:aba7424502dce9a6a12bc8b0c34c8fa04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::multiset. <br /></td></tr>
<tr class="separator:aba7424502dce9a6a12bc8b0c34c8fa04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6668a1fc6b49fcf9c53633e3eb385826"><td class="memTemplParams" colspan="2"><a id="a6668a1fc6b49fcf9c53633e3eb385826"></a>
template&lt;class Archive , class K , class C , class A &gt; </td></tr>
<tr class="memitem:a6668a1fc6b49fcf9c53633e3eb385826"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a6668a1fc6b49fcf9c53633e3eb385826">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::multiset&lt; K, C, A &gt; &amp;multiset)</td></tr>
<tr class="memdesc:a6668a1fc6b49fcf9c53633e3eb385826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::multiset. <br /></td></tr>
<tr class="separator:a6668a1fc6b49fcf9c53633e3eb385826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1f0d917ab00dd67f0b0e7d71737628"><td class="memTemplParams" colspan="2"><a id="aca1f0d917ab00dd67f0b0e7d71737628"></a>
template&lt;class Archive , class T , class C &gt; </td></tr>
<tr class="memitem:aca1f0d917ab00dd67f0b0e7d71737628"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aca1f0d917ab00dd67f0b0e7d71737628">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::stack&lt; T, C &gt; const &amp;stack)</td></tr>
<tr class="memdesc:aca1f0d917ab00dd67f0b0e7d71737628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::stack. <br /></td></tr>
<tr class="separator:aca1f0d917ab00dd67f0b0e7d71737628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f082383d87633cf69bdf0ab3d450ad"><td class="memTemplParams" colspan="2"><a id="af7f082383d87633cf69bdf0ab3d450ad"></a>
template&lt;class Archive , class T , class C &gt; </td></tr>
<tr class="memitem:af7f082383d87633cf69bdf0ab3d450ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#af7f082383d87633cf69bdf0ab3d450ad">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::stack&lt; T, C &gt; &amp;stack)</td></tr>
<tr class="memdesc:af7f082383d87633cf69bdf0ab3d450ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::stack. <br /></td></tr>
<tr class="separator:af7f082383d87633cf69bdf0ab3d450ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c56736b1eca213cb9871171183c1675"><td class="memTemplParams" colspan="2"><a id="a0c56736b1eca213cb9871171183c1675"></a>
template&lt;class Archive , class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:a0c56736b1eca213cb9871171183c1675"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; CharT &gt;, Archive &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a0c56736b1eca213cb9871171183c1675">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;str)</td></tr>
<tr class="memdesc:a0c56736b1eca213cb9871171183c1675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for basic_string types, if binary data is supported. <br /></td></tr>
<tr class="separator:a0c56736b1eca213cb9871171183c1675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0888d39825d481241203372dbc106648"><td class="memTemplParams" colspan="2"><a id="a0888d39825d481241203372dbc106648"></a>
template&lt;class Archive , class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:a0888d39825d481241203372dbc106648"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; CharT &gt;, Archive &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a0888d39825d481241203372dbc106648">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; &amp;str)</td></tr>
<tr class="memdesc:a0888d39825d481241203372dbc106648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for basic_string types, if binary data is supported. <br /></td></tr>
<tr class="separator:a0888d39825d481241203372dbc106648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660edef0c6b018675e109062d459dc82"><td class="memTemplParams" colspan="2"><a id="a660edef0c6b018675e109062d459dc82"></a>
template&lt;class Archive , class ... Types&gt; </td></tr>
<tr class="memitem:a660edef0c6b018675e109062d459dc82"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a660edef0c6b018675e109062d459dc82">CEREAL_SERIALIZE_FUNCTION_NAME</a> (Archive &amp;ar, std::tuple&lt; Types... &gt; &amp;tuple)</td></tr>
<tr class="memdesc:a660edef0c6b018675e109062d459dc82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing for std::tuple. <br /></td></tr>
<tr class="separator:a660edef0c6b018675e109062d459dc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220a6067b52ed669c0c151d76567b561"><td class="memTemplParams" colspan="2"><a id="a220a6067b52ed669c0c151d76567b561"></a>
template&lt;class Archive , class K , class H , class KE , class A &gt; </td></tr>
<tr class="memitem:a220a6067b52ed669c0c151d76567b561"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a220a6067b52ed669c0c151d76567b561">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::unordered_set&lt; K, H, KE, A &gt; const &amp;unordered_set)</td></tr>
<tr class="memdesc:a220a6067b52ed669c0c151d76567b561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::unordered_set. <br /></td></tr>
<tr class="separator:a220a6067b52ed669c0c151d76567b561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b6234fc5a858bd294a833ccc9045ba"><td class="memTemplParams" colspan="2"><a id="af0b6234fc5a858bd294a833ccc9045ba"></a>
template&lt;class Archive , class K , class H , class KE , class A &gt; </td></tr>
<tr class="memitem:af0b6234fc5a858bd294a833ccc9045ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#af0b6234fc5a858bd294a833ccc9045ba">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::unordered_set&lt; K, H, KE, A &gt; &amp;unordered_set)</td></tr>
<tr class="memdesc:af0b6234fc5a858bd294a833ccc9045ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::unordered_set. <br /></td></tr>
<tr class="separator:af0b6234fc5a858bd294a833ccc9045ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4385e91ff798d9c5f8c336470011b889"><td class="memTemplParams" colspan="2"><a id="a4385e91ff798d9c5f8c336470011b889"></a>
template&lt;class Archive , class K , class H , class KE , class A &gt; </td></tr>
<tr class="memitem:a4385e91ff798d9c5f8c336470011b889"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a4385e91ff798d9c5f8c336470011b889">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::unordered_multiset&lt; K, H, KE, A &gt; const &amp;unordered_multiset)</td></tr>
<tr class="memdesc:a4385e91ff798d9c5f8c336470011b889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::unordered_multiset. <br /></td></tr>
<tr class="separator:a4385e91ff798d9c5f8c336470011b889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da956bad9ffcece46b8b3578a05567a"><td class="memTemplParams" colspan="2"><a id="a7da956bad9ffcece46b8b3578a05567a"></a>
template&lt;class Archive , class K , class H , class KE , class A &gt; </td></tr>
<tr class="memitem:a7da956bad9ffcece46b8b3578a05567a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a7da956bad9ffcece46b8b3578a05567a">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::unordered_multiset&lt; K, H, KE, A &gt; &amp;unordered_multiset)</td></tr>
<tr class="memdesc:a7da956bad9ffcece46b8b3578a05567a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::unordered_multiset. <br /></td></tr>
<tr class="separator:a7da956bad9ffcece46b8b3578a05567a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c80c9e74c022531318b7df731c1f73"><td class="memTemplParams" colspan="2"><a id="a83c80c9e74c022531318b7df731c1f73"></a>
template&lt;class Archive , class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a83c80c9e74c022531318b7df731c1f73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a83c80c9e74c022531318b7df731c1f73">CEREAL_SERIALIZE_FUNCTION_NAME</a> (Archive &amp;ar, std::pair&lt; T1, T2 &gt; &amp;pair)</td></tr>
<tr class="memdesc:a83c80c9e74c022531318b7df731c1f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing for std::pair. <br /></td></tr>
<tr class="separator:a83c80c9e74c022531318b7df731c1f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebed7bbe6c0dacb0e02cf62306c6546f"><td class="memTemplParams" colspan="2"><a id="aebed7bbe6c0dacb0e02cf62306c6546f"></a>
template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:aebed7bbe6c0dacb0e02cf62306c6546f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value &amp;&amp;std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aebed7bbe6c0dacb0e02cf62306c6546f">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::valarray&lt; T &gt; const &amp;valarray)</td></tr>
<tr class="memdesc:aebed7bbe6c0dacb0e02cf62306c6546f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::valarray arithmetic types, using binary serialization, if supported. <br /></td></tr>
<tr class="separator:aebed7bbe6c0dacb0e02cf62306c6546f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ffe563cc2d42f242fb634ee43e657dc"><td class="memTemplParams" colspan="2"><a id="a4ffe563cc2d42f242fb634ee43e657dc"></a>
template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a4ffe563cc2d42f242fb634ee43e657dc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value &amp;&amp;std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a4ffe563cc2d42f242fb634ee43e657dc">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::valarray&lt; T &gt; &amp;valarray)</td></tr>
<tr class="memdesc:a4ffe563cc2d42f242fb634ee43e657dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::valarray arithmetic types, using binary serialization, if supported. <br /></td></tr>
<tr class="separator:a4ffe563cc2d42f242fb634ee43e657dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf57bfdff82b7b9c448ff92cc05e63c"><td class="memTemplParams" colspan="2"><a id="abdf57bfdff82b7b9c448ff92cc05e63c"></a>
template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:abdf57bfdff82b7b9c448ff92cc05e63c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value||!std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#abdf57bfdff82b7b9c448ff92cc05e63c">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::valarray&lt; T &gt; const &amp;valarray)</td></tr>
<tr class="memdesc:abdf57bfdff82b7b9c448ff92cc05e63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::valarray all other types. <br /></td></tr>
<tr class="separator:abdf57bfdff82b7b9c448ff92cc05e63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815c350d8ae5bbbf7ba42ff388796dd2"><td class="memTemplParams" colspan="2"><a id="a815c350d8ae5bbbf7ba42ff388796dd2"></a>
template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a815c350d8ae5bbbf7ba42ff388796dd2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value||!std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a815c350d8ae5bbbf7ba42ff388796dd2">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::valarray&lt; T &gt; &amp;valarray)</td></tr>
<tr class="memdesc:a815c350d8ae5bbbf7ba42ff388796dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::valarray all other types. <br /></td></tr>
<tr class="separator:a815c350d8ae5bbbf7ba42ff388796dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47624047ae8b341de607f9ff1306f472"><td class="memTemplParams" colspan="2"><a id="a47624047ae8b341de607f9ff1306f472"></a>
template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:a47624047ae8b341de607f9ff1306f472"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value &amp;&amp;std::is_arithmetic&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, bool &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a47624047ae8b341de607f9ff1306f472">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::vector&lt; T, A &gt; const &amp;vector)</td></tr>
<tr class="memdesc:a47624047ae8b341de607f9ff1306f472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for std::vectors of arithmetic (but not bool) using binary serialization, if supported. <br /></td></tr>
<tr class="separator:a47624047ae8b341de607f9ff1306f472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ef05e6fe2f50deb4a33c04980b7439"><td class="memTemplParams" colspan="2"><a id="ac3ef05e6fe2f50deb4a33c04980b7439"></a>
template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:ac3ef05e6fe2f50deb4a33c04980b7439"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value &amp;&amp;std::is_arithmetic&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, bool &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ac3ef05e6fe2f50deb4a33c04980b7439">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::vector&lt; T, A &gt; &amp;vector)</td></tr>
<tr class="memdesc:ac3ef05e6fe2f50deb4a33c04980b7439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for std::vectors of arithmetic (but not bool) using binary serialization, if supported. <br /></td></tr>
<tr class="separator:ac3ef05e6fe2f50deb4a33c04980b7439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f0f1f7694aaf6bba5b14fc81a30c10"><td class="memTemplParams" colspan="2"><a id="a85f0f1f7694aaf6bba5b14fc81a30c10"></a>
template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:a85f0f1f7694aaf6bba5b14fc81a30c10"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value||!std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a85f0f1f7694aaf6bba5b14fc81a30c10">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::vector&lt; T, A &gt; const &amp;vector)</td></tr>
<tr class="memdesc:a85f0f1f7694aaf6bba5b14fc81a30c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for non-arithmetic vector types. <br /></td></tr>
<tr class="separator:a85f0f1f7694aaf6bba5b14fc81a30c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fedfe556084ce0c581bc3dec258cde5"><td class="memTemplParams" colspan="2"><a id="a0fedfe556084ce0c581bc3dec258cde5"></a>
template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:a0fedfe556084ce0c581bc3dec258cde5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value||!std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a0fedfe556084ce0c581bc3dec258cde5">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::vector&lt; T, A &gt; &amp;vector)</td></tr>
<tr class="memdesc:a0fedfe556084ce0c581bc3dec258cde5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for non-arithmetic vector types. <br /></td></tr>
<tr class="separator:a0fedfe556084ce0c581bc3dec258cde5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b613c5fc7ae5ec8f8216a6337955a7"><td class="memTemplParams" colspan="2"><a id="a76b613c5fc7ae5ec8f8216a6337955a7"></a>
template&lt;class Archive , class A &gt; </td></tr>
<tr class="memitem:a76b613c5fc7ae5ec8f8216a6337955a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a76b613c5fc7ae5ec8f8216a6337955a7">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::vector&lt; bool, A &gt; const &amp;vector)</td></tr>
<tr class="memdesc:a76b613c5fc7ae5ec8f8216a6337955a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for bool vector types. <br /></td></tr>
<tr class="separator:a76b613c5fc7ae5ec8f8216a6337955a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c7d1d922569ba782c8ec6d8f79b3e8"><td class="memTemplParams" colspan="2"><a id="a09c7d1d922569ba782c8ec6d8f79b3e8"></a>
template&lt;class Archive , class A &gt; </td></tr>
<tr class="memitem:a09c7d1d922569ba782c8ec6d8f79b3e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a09c7d1d922569ba782c8ec6d8f79b3e8">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::vector&lt; bool, A &gt; &amp;vector)</td></tr>
<tr class="memdesc:a09c7d1d922569ba782c8ec6d8f79b3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for bool vector types. <br /></td></tr>
<tr class="separator:a09c7d1d922569ba782c8ec6d8f79b3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>in certain simple scenarios. They should probably not be used if maximizing performance is the main objective. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aba657f7ef148daa498dc4fa9e579b01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba657f7ef148daa498dc4fa9e579b01e">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecereal.html#aba657f7ef148daa498dc4fa9e579b01e">cereal::size_type</a> = typedef <a class="el" href="macros_8hpp.html#a2ad098b163a5f4829eb00fd7fb0b408d">CEREAL_SIZE_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size type used by cereal. </p>
<p>To ensure compatability between 32, 64, etc bit machines, we need to use a fixed size type instead of size_t, which may vary from machine to machine.</p>
<p>The default value for CEREAL_SIZE_TYPE is specified in <a class="el" href="macros_8hpp.html" title="Preprocessor macros that can customise the cereal library.">cereal/macros.hpp</a> </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a95185aa9f39e4ac382bb6631beb68a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95185aa9f39e4ac382bb6631beb68a67">&#9670;&nbsp;</a></span>Flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecereal.html#a95185aa9f39e4ac382bb6631beb68a67">cereal::Flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special flags for archives. </p>
<p>AllowEmptyClassElision This allows for empty classes to be serialized even if they do not provide a serialization function. Classes with no data members are considered to be empty. Be warned that if this is enabled and you attempt to serialize an empty class with improperly formed serialize or load/save functions, no static error will occur - the error will propogate silently and your intended serialization functions may not be called. You can manually ensure that your classes that have custom serialization are correct by using the traits is_output_serializable and is_input_serializable in <a class="el" href="traits_8hpp.html" title="Internal type trait support.">cereal/details/traits.hpp</a>. </p>

</div>
</div>
<a id="ac28bb730353e53b3066cc679e63bb108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28bb730353e53b3066cc679e63bb108">&#9670;&nbsp;</a></span>specialization</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , specialization S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum specialization</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A specifier used in conjunction with <a class="el" href="structcereal_1_1specialize.html" title="A class used to disambiguate cases where cereal cannot detect a unique way of serializing a class.">cereal::specialize</a> to disambiguate serialization in special cases </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a49547021764b554ce332679c9f9fec70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49547021764b554ce332679c9f9fec70">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt;<a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt;T&gt;, Archive&gt;::value &amp;&amp; std::is_arithmetic&lt;T&gt;::value, void&gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loading for std::array primitive types using binary serialization, if supported </p>

</div>
</div>
<a id="a7dd86a3c7ebb03502832158513b91ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd86a3c7ebb03502832158513b91ee3">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt;<a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt;T&gt;, Archive&gt;::value &amp;&amp; std::is_arithmetic&lt;T&gt;::value, void&gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Saving for std::array primitive types using binary serialization, if supported </p>

</div>
</div>
<a id="a397c996c1b3e8bdcb3f43f11edf91126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397c996c1b3e8bdcb3f43f11edf91126">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , size_t N, traits::EnableIf&lt; traits::is_output_serializable&lt; BinaryData&lt; std::uint32_t &gt;, Archive &gt;::value &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::bitset&lt; N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializing (save) for std::bitset when <a class="el" href="structcereal_1_1BinaryData.html" title="A wrapper around data that can be serialized in a binary fashion.">BinaryData</a> optimization supported. </p>
<p>Serializing (save) for std::bitset when <a class="el" href="structcereal_1_1BinaryData.html" title="A wrapper around data that can be serialized in a binary fashion.">BinaryData</a> is not supported. </p>

</div>
</div>
<a id="a676a85ac8cfcd512a743f930a10b6770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676a85ac8cfcd512a743f930a10b6770">&#9670;&nbsp;</a></span>CEREAL_SERIALIZE_FUNCTION_NAME() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SERIALIZE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialization for raw pointers. </p>
<p>This exists only to throw a static_assert to let users know we don't support raw pointers. </p>

</div>
</div>
<a id="a64ec0a04e5dc57a58de5e78b5a87b8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ec0a04e5dc57a58de5e78b5a87b8d3">&#9670;&nbsp;</a></span>CEREAL_SERIALIZE_FUNCTION_NAME() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cereal::CEREAL_SERIALIZE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializing NVP types to binary. </p>
<p>Serializing NVP types to portable binary. </p>

</div>
</div>
<a id="ac5fb9b1468920e7e23cb2817e65fed4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5fb9b1468920e7e23cb2817e65fed4a">&#9670;&nbsp;</a></span>CEREAL_SERIALIZE_FUNCTION_NAME() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cereal::CEREAL_SERIALIZE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializing SizeTags to binary. </p>
<p>Serializing SizeTags to portable binary. </p>

</div>
</div>
<a id="a1153b7ce7ffbb86e2c81e076a252938e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1153b7ce7ffbb86e2c81e076a252938e">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after a type is serialized to tear down any special archive state for processing some type </p>

</div>
</div>
<a id="a99326c431920835d61e5bfc51b865f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99326c431920835d61e5bfc51b865f22">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for NVPs for JSON archives. </p>
<p>NVPs do not start or finish nodes - they just set up the names </p>

</div>
</div>
<a id="a5cdc10b14dce9340a8df6cb18ac74554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cdc10b14dce9340a8df6cb18ac74554">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;::value, !traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_input_serialization, JSONInputArchive &gt;::value, !traits::has_minimal_input_serialization&lt; T, JSONInputArchive &gt;::value &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for all other types other for JSON archives. </p>
<p>Epilogue for arithmetic types for JSON archives. </p>

</div>
</div>
<a id="a3bec173adc6146ecc712921c2d257ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bec173adc6146ecc712921c2d257ade">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for NVPs for JSON archives. </p>
<p>NVPs do not start or finish nodes - they just set up the names </p>

</div>
</div>
<a id="ab92526cf5d3f4a642d918a027d2e4567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92526cf5d3f4a642d918a027d2e4567">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for SizeTags for JSON archives. </p>
<p>SizeTags are strictly ignored for JSON </p>

</div>
</div>
<a id="abb6adc568591c0a525f2c16ea5912c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6adc568591c0a525f2c16ea5912c5b">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;::value, !traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_output_serialization, JSONOutputArchive &gt;::value, !traits::has_minimal_output_serialization&lt; T, JSONOutputArchive &gt;::value &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for all other types other for JSON archives (except minimal types) </p>
<p>Epilogue for arithmetic types for JSON archives.</p>
<p>Finishes the node created in the prologue</p>
<p>Minimal types do not start or finish nodes </p>

</div>
</div>
<a id="a906ef65c3ab455598f768431bcd5f37d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a906ef65c3ab455598f768431bcd5f37d">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for NVPs for XML output archives. </p>
<p>NVPs do not start or finish nodes - they just set up the names </p>

</div>
</div>
<a id="ac3700f36066026da589faa60fed7ca53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3700f36066026da589faa60fed7ca53">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for SizeTags for XML output archives. </p>
<p>SizeTags do not start or finish nodes </p>

</div>
</div>
<a id="a16ca55f7d5556527de1584198ea3c414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ca55f7d5556527de1584198ea3c414">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::DisableIf&lt; traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_output_serialization, XMLOutputArchive &gt;::value||traits::has_minimal_output_serialization&lt; T, XMLOutputArchive &gt;::value &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for all other types other for XML output archives (except minimal types) </p>
<p>Finishes the node created in the prologue</p>
<p>Minimal types do not start or end nodes </p>

</div>
</div>
<a id="a8093b5f7cfd618fae6350ef7b2c09453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8093b5f7cfd618fae6350ef7b2c09453">&#9670;&nbsp;</a></span>prologue() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called before a type is serialized to set up any special archive state for processing some type</p>
<p>If designing a serializer that needs to set up any kind of special state or output extra information for a type, specialize this function for the archive type and the types that require the extra information. </p>

</div>
</div>
<a id="af88fce78fe97297ab4d22a607fee1e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88fce78fe97297ab4d22a607fee1e07">&#9670;&nbsp;</a></span>prologue() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;::value, !traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_input_serialization, JSONInputArchive &gt;::value, !traits::has_minimal_input_serialization&lt; T, JSONInputArchive &gt;::value &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for all other types for JSON archives. </p>
<p>Prologue for arithmetic types for JSON archives. </p>

</div>
</div>
<a id="ac267b8915a13f4433fc25aa9d310ee40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac267b8915a13f4433fc25aa9d310ee40">&#9670;&nbsp;</a></span>prologue() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for NVPs for JSON archives. </p>
<p>NVPs do not start or finish nodes - they just set up the names </p>

</div>
</div>
<a id="a5f7ec98da774f9e0af596620859d8ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7ec98da774f9e0af596620859d8ccb">&#9670;&nbsp;</a></span>prologue() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for SizeTags for JSON archives. </p>
<p>SizeTags are strictly ignored for JSON, they just indicate that the current node should be made into an array </p>

</div>
</div>
<a id="aba2924cd871a88c20023171f74a68d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2924cd871a88c20023171f74a68d39">&#9670;&nbsp;</a></span>prologue() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;::value, !traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_output_serialization, JSONOutputArchive &gt;::value, !traits::has_minimal_output_serialization&lt; T, JSONOutputArchive &gt;::value &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for all other types for JSON archives (except minimal types) </p>
<p>Prologue for arithmetic types for JSON archives.</p>
<p>Starts a new node, named either automatically or by some NVP, that may be given data by the type about to be archived</p>
<p>Minimal types do not start or finish nodes </p>

</div>
</div>
<a id="a2582cc8477f9482910fc5733e13f75f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2582cc8477f9482910fc5733e13f75f7">&#9670;&nbsp;</a></span>prologue() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for NVPs for XML output archives. </p>
<p>NVPs do not start or finish nodes - they just set up the names </p>

</div>
</div>
<a id="adbb541e9594201d78a04cb11ad806ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb541e9594201d78a04cb11ad806ba0">&#9670;&nbsp;</a></span>prologue() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for SizeTags for XML output archives. </p>
<p>SizeTags do not start or finish nodes </p>

</div>
</div>
<a id="af751c02a4443b571fee21416a4b899c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af751c02a4443b571fee21416a4b899c1">&#9670;&nbsp;</a></span>prologue() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::DisableIf&lt; traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_output_serialization, XMLOutputArchive &gt;::value||traits::has_minimal_output_serialization&lt; T, XMLOutputArchive &gt;::value &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for all other types for XML output archives (except minimal types) </p>
<p>Starts a new node, named either automatically or by some NVP, that may be given data by the type about to be archived</p>
<p>Minimal types do not start or end nodes </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecereal.html">cereal</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
